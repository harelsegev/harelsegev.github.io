<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on RAT In Mi Kitchen</title>
    <link>https://harelsegev.github.io/posts/</link>
    <description>Recent content in Posts on RAT In Mi Kitchen</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 29 Oct 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://harelsegev.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>$I30 Parsers Output False Entries. Here&#39;s Why</title>
      <link>https://harelsegev.github.io/posts/i30-parsers-output-false-entries.-heres-why/</link>
      <pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://harelsegev.github.io/posts/i30-parsers-output-false-entries.-heres-why/</guid>
      <description>In the README page of my tool, INDXRipper (Go check it out! It&amp;rsquo;s really cool), down in the &amp;ldquo;Limitations&amp;rdquo; section, I gave some warnings regarding the reliability of the tool:
The tool may give false results. While false positives are rare, they are possible.
Partially overwritten entries may not be found. If they are found, though, the tool may give you false information.
These shortcomings apply to every $I30 parser, and in this post - I&amp;rsquo;ll explain why.</description>
      <content:encoded><![CDATA[<p>In the README page of my tool, <a href="https://github.com/harelsegev/INDXRipper">INDXRipper</a> (Go check it out! It&rsquo;s really cool), down in the &ldquo;Limitations&rdquo; section, I gave some warnings regarding the reliability of the tool:</p>
<blockquote>
<p>The tool may give false results. While false positives are rare, they are possible.</p>
</blockquote>
<blockquote>
<p>Partially overwritten entries may not be found. If they are found, though, the tool may give you false information.</p>
</blockquote>
<p>These shortcomings apply to <em>every</em> $I30 parser, and in this post - I&rsquo;ll explain why. First, I will give an overview of directories in NTFS, and talk a bit about how $I30 parsers work. Then, I&rsquo;ll show you a case where a $I30 parser outputs a false entry, and explain how I try to avoid them in INDXRipper.</p>
<h2 id="ntfs-directories">NTFS Directories</h2>
<p>In NTFS, a directory is ultimately a collection of entries - one (or more) for every file it contains. Those entries live in a sorted data structure called a B-tree, to allow fast access to files. B-trees are similar to binary search trees, except they are not binary - a node can have more than 2 child-nodes:</p>
<p><img loading="lazy" src="images/b_tree.svg" alt=""  />
</p>
<p>As you can see, each node can store multiple entries. The nodes are laid out sequentially inside an index attribute (<code>$INDEX_ROOT</code> or <code>$INDEX_ALLOCATION</code>), so a $I30 parser can iterate over them without having to deal with the tree structure.</p>
<p>Inside each node, the entries are sorted by filename. As the following diagram illustrates, they can have different sizes - so each entry has a 2-byte field containing the relative offset of the next entry:</p>
<p><img loading="lazy" src="images/i30_before_deletion.svg" alt=""  />
</p>
<p>When a file is moved in or out of a directory, an entry is created or removed from the tree, respectively. This sometimes causes the tree to rebalance itself - which may cause other, non-related entries to be removed from their node and re-created in another node.</p>
<p>Let&rsquo;s see what happens if entry <em><strong>B</strong></em> is removed from the above 4-entry node:</p>
<p><img loading="lazy" src="images/i30_after_deletion.svg" alt=""  />
</p>
<p>Entries <em><strong>C</strong></em> and <em><strong>D</strong></em> were simply shifted left. Now, this node contains <em>slack space</em> - space at the end of the node that isn&rsquo;t used by either one of the entries, and is marked here with red diagonal stripes. As you can see, it contains a complete copy of entry <em><strong>D</strong></em> and a partially overwritten copy of entry <em><strong>C</strong></em> from before they were shifted.</p>
<p>These diagrams showcase some of the unique qualities of this artifact:</p>
<ul>
<li>Not every removed entry will have remnants in slack space (Entry <em><strong>B</strong></em>)</li>
<li>Entries that were <strong>not</strong> removed may have remnants in slack space (Entry <em><strong>C</strong></em> and <em><strong>D</strong></em>)</li>
<li>Entries in slack space may be partially overwritten (Entry <em><strong>C</strong></em>)</li>
</ul>
<h2 id="carving-entries-from-i30-slack-space">Carving Entries From $I30 Slack Space</h2>
<p>As we have just seen, the content of $I30 slack space is unpredictable. To recover file metadata from it, $I30 parsers utilize techniques that are very similar to file carving.</p>
<p>File carvers often rely on file signatures to detect files in unallocated space. Unfortunately, $I30 entries don&rsquo;t have a standard header or a fixed signature they can be detected with. However, the file metadata they contain can itself be used to build carving rules.</p>
<p>Most $I30 parsers base their carving rules on the set of MACB timestamps that $I30 entries contain. A sequence of 4 timestamps makes an really good carving rule, because timestamps only make sense within a very small range of values.</p>
<p>A Windows FILETIME timestamp has a range of +/- 29,227 years from its epoch of 1601. If you find a sequence of 4 values that are all within a reasonable range when interpreted as timestamps (say, 1990 - 2030), that&rsquo;s probably not a coincidence.</p>
<h2 id="false-entries">False Entries</h2>
<p>Sometimes it <strong>is</strong> a coincidence, though. Here&rsquo;s a snippet from a really weird output I got from <a href="https://github.com/williballenthin/INDXParse">INDXParse</a> when I executed it on the index attribute of a directory on my system:</p>
<p><img loading="lazy" src="images/indxparse_output.png" alt=""  />
</p>
<p>The file in the first line looks normal. The last two lines, however - are messed up:</p>
<ul>
<li>The second line is almost completely empty, except an unprintable character and a lowercase O in the filename field.</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<ul>
<li>The file in the third line has a physical size of roughly 118 <strong>Petabytes</strong>, which is a <em>tiny</em> bit more than my hard drive&rsquo;s storage capacity. Its name looks cut-off, and a creation time of 2015 is odd, considering all the other files in that directory were created much later.</li>
</ul>
<p>The entry this data was pulled from is partially overwritten - which might explain this output. Let&rsquo;s take a look at this entry in hex, and try to figure out what&rsquo;s going on:</p>
<p><img loading="lazy" src="images/slack_entry_fragment.png" alt=""  />
</p>
<p>What&rsquo;s marked in yellow is a special entry indicating the end of a node. Everything below it is in slack space - including the entry we&rsquo;re interested in. Although it&rsquo;s partially overwritten, the file metadata inside our entry is still intact:</p>
<ul>
<li>The filename is marked in blue.</li>
<li>The 4 MACB timestamps are marked in green.</li>
<li>The file&rsquo;s physical size is marked in brown.</li>
<li>The red byte is the filename length in characters.</li>
</ul>
<p>What&rsquo;s marked in purple is the <em>file reference</em> of the parent directory. It&rsquo;s composed of the directory&rsquo;s MFT entry number (first 6 bytes) and a sequence number (last 2 bytes).</p>
<p>All of this file metadata is completely valid. This is the output we would have got if this entry were parsed correctly:</p>
<table>
<thead>
<tr>
<th>Filename</th>
<th>Physical Size</th>
<th>Logical Size</th>
<th>Creation Time</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>AlarmsAppList.targetsize-16_contrast-black.png</code></td>
<td>4096</td>
<td>243</td>
<td>06/03/2020</td>
</tr>
</tbody>
</table>
<p>INDXParse should have detected the set of 4 MACB timestamps, and should have given us this output. What went wrong? Well&hellip; everything.</p>
<p>By pure chance, the file reference of the parent directory is also a reasonable timestamp:</p>
<p><img loading="lazy" src="images/timestamp.png" alt=""  />
</p>
<p>Looks familiar? It&rsquo;s the weird creation time from the third output line! INDXParse detected this file reference as a <strong>timestamp</strong>. The fields that come after it are the <em>actual</em> timestamps, so that lead to the detection of a wrong set of 4 timestamps:</p>
<p><img loading="lazy" src="images/false_entry.png" alt=""  />
</p>
<p>This - my friends, is a false entry. It overlaps with our real entry - which makes this a bit confusing. The fields marked <em>here</em> belong to the false entry. Looking at them, it becomes clear that INDXParse detected this false entry instead of the real one.</p>
<p>Let&rsquo;s take a second look at the output of INDXParse:</p>
<p><img loading="lazy" src="images/indxparse_output.png" alt=""  />
</p>
<ul>
<li>As we have just seen, the creation time in the false entry - <code>54 2B 00 00 00 00 D1 01</code>, matches the creation time in the third output line, and is actually the parent directory reference in the real entry.</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<ul>
<li>The physical size in the false entry (marked in brown) matches the physical size in the third output line (~118 petabytes). This value is the last access time in the real entry, which explains why it is so ridiculous as a file size.</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<ul>
<li>The filename (marked in blue) starts with 0x04, which is an EOT character. Then there&rsquo;s 0x6F, which is a lowercase O, and 0x0D - a carriage return character (CR), which excel interprets as a new line. This character sequence is actually the second output line.</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<ul>
<li>The rest of the filename is in the third output line. It&rsquo;s cut-off, because the filename length in the false entry (marked in red) is a lot shorter than the real one.</li>
</ul>
<h2 id="avoiding-false-entries">Avoiding False Entries</h2>
<p>Unfortunately, false entries cannot be entirely avoided. When carving data from an unstructured binary blob, there&rsquo;s always a risk of false positives. Nevertheless, the false positive rate can be reduced with more in-depth validation of the carved data.</p>
<p>The false entry shown above can be easily identified as one:</p>
<ul>
<li>The filename contains control characters. While most of the characters in the Unicode &ldquo;Control&rdquo; category are allowed in filenames, they are very rarely used in them.</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<ul>
<li>The file&rsquo;s physical size, besides being absolutely ridiculous, is not a multiple of the file-system&rsquo;s cluster size. This is an obvious red flag.</li>
</ul>
<p>I implemented similar validations in <em>my</em> tool, INDXRipper - so in this case, it ignores the false entry and outputs the real one, as it should. Those validations aren&rsquo;t foolproof, though. $I30 slack space is unpredictable, so there&rsquo;s always a chance they will fail.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>The Forensic Value of the (Other) WSH Registry Key</title>
      <link>https://harelsegev.github.io/posts/the-forensic-value-of-the-other-wsh-registry-key/</link>
      <pubDate>Thu, 13 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://harelsegev.github.io/posts/the-forensic-value-of-the-other-wsh-registry-key/</guid>
      <description>WSH (Windows Script Host) is an automation tool built into Windows, providing powerful scripting abilities. It was introduced in Windows 98, long predating .NET and PowerShell. Whilst being largely abandoned by system administrators, It is sometimes used by attackers to evade detection and obfuscate their infection chains.
Typically, an attacker will drop a malicious script on disk - a .vbs, .js or a .wsf file, and then execute it using either the WScript or the CScript host.</description>
      <content:encoded><![CDATA[<p><em>WSH</em> (Windows Script Host) is an automation tool built into Windows, providing powerful scripting abilities. It was introduced in Windows 98, long predating .NET and PowerShell. Whilst being largely abandoned by system administrators, It is sometimes used by attackers to evade detection and obfuscate their infection chains.</p>
<p>Typically, an attacker will drop a malicious script on disk - a <code>.vbs</code>, <code>.js</code> or a <code>.wsf</code> file, and then execute it using either the WScript or the CScript host.</p>
<p>System-wide WSH settings are stored in the SOFTWARE hive, in the Windows Script Host key, and can be examined using the <code>wsh_settings</code> RegRipper plugin:</p>
<p><img loading="lazy" src="images/wsh_settings_hklm.png" alt=""  />
</p>
<p>This post is not about <em>this</em> key, though. It&rsquo;s about a matching Windows Script Host key in the NTUSER.DAT hive, which stores the user-specific WSH settings:</p>
<p><img loading="lazy" src="images/wsh_settings_hkcu.png" alt=""  />
</p>
<p>Interestingly, the WSH key in NTUSER.DAT does not exist by default. It is only created when the user executes WScript or CScript for the first time.</p>
<p>Because they have their own sub-key, a change in the settings does not affect the last write timestamp of the WSH key. It won&rsquo;t usually change after the key is created, even if the settings are changed.</p>
<p>The big question is - can we use this timestamp to determine the first time a user executed WScript or CScript? Well, maybe. It depends on whether values or sub-keys <em>other</em> than Settings are ever created beneath the WSH key.</p>
<p>I&rsquo;ve done some testing, and I couldn&rsquo;t get either WScript or CScript to create (or even query) other values or sub-keys. I believe it <em>never</em> happens. I cannot be entirely sure, but I&rsquo;m somewhat confident.</p>
<p><img loading="lazy" src="images/wscript_procmon.png" alt=""  />
</p>
<p>If I&rsquo;m right - then the last write time of the WSH key <strong>always</strong> indicates its creation time, and I can see all sorts of exciting things we can use this for:</p>
<ul>
<li>Determine the first time a user executed WScript or CScript. If WSH isn&rsquo;t typically used in your environment, this may be worth hunting for.</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<ul>
<li>Attribute the execution of a WSH script to a specific user account. If a <code>.js</code> script were dropped on disk, and a user&rsquo;s WSH key were then immediately created, I&rsquo;d bet that user executed the script.</li>
</ul>
<blockquote>
<p><strong>Note:</strong> If WScript or CScript is executed with SYSTEM privileges, the Windows Script Host key will be created in the DEFAULT hive.</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>The Mystery of the HeapLeakDetection Registry Key</title>
      <link>https://harelsegev.github.io/posts/the-mystery-of-the-heapleakdetection-registry-key/</link>
      <pubDate>Wed, 20 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://harelsegev.github.io/posts/the-mystery-of-the-heapleakdetection-registry-key/</guid>
      <description>I was working on a case the other day, when I first came across a rather interesting registry key, HKLM\Software\Microsoft\RADAR\HeapLeakDetection\DiagnosedApplications. It caught my eye, because it has sub-keys for (what appears to be) applications executed on the system. This is what it looks like on my own system:
It has quite a few sub-keys, and each one has a LastDetectionTime QWORD value, containing what appears to be a Windows FILETIME timestamp:</description>
      <content:encoded><![CDATA[<p>I was working on a case the other day, when I first came across a rather interesting registry key, <code>HKLM\Software\Microsoft\RADAR\HeapLeakDetection\DiagnosedApplications</code>. It caught my eye, because it has sub-keys for (what appears to be) applications executed on the system. This is what it looks like on my own system:</p>
<p><img loading="lazy" src="images/regedit_key_hierarchy.png" alt=""  />
</p>
<p>It has quite a few sub-keys, and each one has a <em>LastDetectionTime</em> QWORD value, containing what appears to be a Windows FILETIME timestamp:</p>
<p><img loading="lazy" src="images/regedit_last_detection_time.png" alt=""  />
</p>
<p>This key is associated with the Memory Leak Diagnoser component of Windows Resource Exhaustion Detection and Resolution (RADAR). RADAR is a technology embedded in Windows to detect memory leaks in real-time, so that data can be collected and used to correct issues in applications.</p>
<p>RADAR is surprisingly old; it was introduced in Windows Vista. Nevertheless, I couldn&rsquo;t find any research into this registry key - so I had to conduct my own. With forensics in mind, I tried to answer these 2 questions:</p>
<ul>
<li>Under what conditions is a sub-key created beneath the <em>DiagnosedApplications</em> key?</li>
<li>Under what conditions is the <em>LastDetectionTime</em> value updated?</li>
</ul>
<p>My research was conducted on Windows 10 machines, and therefore may not apply to prior versions of Windows.</p>
<h2 id="looking-at-the-settings">Looking at the Settings</h2>
<p>Luckily, there&rsquo;s a <em>Settings</em> key beneath the <em>HeapLeakDetection</em> key:</p>
<p><img loading="lazy" src="images/regedit_settings.png" alt=""  />
</p>
<p>Settings are always helpful when you&rsquo;re trying to figure out how something works. Looking at these values, I already had some hypotheses. I figured whether an application is diagnosed has something to do with the amount of memory it allocated.</p>
<p>I had a guess that <em>CommitFloor</em> and <em>CommitCeiling</em> are actually in megabytes, and that the amount of committed memory has to lie between them for a process to be registered. That lead me to write a little C program, to test this theory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// set nAllocatedSize to be between CommitFloor and CommitCeiling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t nAllocatedSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">250</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(VirtualAlloc(NULL, nAllocatedSize, MEM_RESERVE <span style="color:#f92672">|</span> MEM_COMMIT, PAGE_READWRITE)) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Committed 250 MB of memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">&#34;Sleeping...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>            Sleep(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I executed the binary on 2 of my machines, and the results threw me off completely. On one of them, it was registered after a few minutes - but on the other one it wasn&rsquo;t registered at all. They&rsquo;re both running the same Windows 10 version, so what&rsquo;s going on?</p>
<h2 id="reverse-engineering-rdrpreadheapleaksettings">Reverse Engineering <em>RdrpReadHeapLeakSettings</em></h2>
<p>To figure this out, I needed more information. Using Procmon, I was able to pinpoint the DLL which manages the <em>DiagnosedApplications</em> registry key:</p>
<p><img loading="lazy" src="images/procmon.png" alt=""  />
</p>
<p>I figured I should start my analysis in the <em>RdrpReadHeapLeakSettings</em> function. I hoped it would help me understand the settings better. Take <em>DetectionInterval</em>, for example; it&rsquo;s 0x1E, or 30 decimal - but 30 what? seconds? minutes? I had no idea.</p>
<p><img loading="lazy" src="images/physics_meme.png" alt=""  />
</p>
<p>This turned out to be a great idea, because the function transforms each value in a way that enabled me to understand what it means. For example, the <em>DetectionInterval</em> value is multiplied by 86400 after it is read from the registry. 86400 happens to be 60 * 60 * 24. This means <em>DetectionInterval</em> is stored days, and is converted to seconds:</p>
<p><img loading="lazy" src="images/ida32_DetectionInterval.png" alt=""  />
</p>
<p>In a similar fashion, I was able to conclude that <em>TimerInterval</em> is stored in minutes.</p>
<p><em>DetectionInterval</em> is stored in a global variable after it&rsquo;s converted to seconds - to make it available for other functions to use. This is also the case for <em>CommitThreshold</em>, <em>MaxReports</em> and <em>TimerInterval</em>. However, both <em>CommitFloor</em> and <em>CommitCeiling</em> aren&rsquo;t stored anywhere after they&rsquo;re read. I doubt whether they&rsquo;re actually used at all!</p>
<p>The next value I looked at is <em>CommitThreshold</em>, which seems to be 5 by default. After it is read from the registry, the function checks if it&rsquo;s between 1 to 100:</p>
<p><img loading="lazy" src="images/ida64_CommitThreshold_01.png" alt=""  />
</p>
<p>After that, there&rsquo;s a call to <em>NtQuerySystemInformation</em> to get a <em>SystemBasicInformation</em> struct. Unfortunately, the structure of this struct is not documented on MSDN:</p>
<p><img loading="lazy" src="images/msdn_SystemBasicInformation.png" alt=""  />
</p>
<p>Nevertheless, I found documentation for it on some other, rather questionable website. Then, I was able to define it as a struct in IDA Pro. What I found then, was the explanation to the confusing results of my test:</p>
<p><img loading="lazy" src="images/ida64_CommitThreshold_02.png" alt=""  />
</p>
<p><em>CommitThreshold</em> is multiplied by <code>(PageSize * NumberOfPhysicalPages) / 100</code>. That lead me to conclude it&rsquo;s the amount of memory an application has to commit in order to get diagnosed, as a percentage of the total amount of physical memory on the system.</p>
<p>I was able to verify this theory through further testing. This artifact behaves differently depending on the amount of RAM installed in the machine.</p>
<p>The 250MBs my test application allocated are more than 5 percent out of the 4GBs of RAM installed in the first machine I tested on, but they&rsquo;re less than 5 percent out of the 8GBs installed in my other machine.</p>
<h2 id="looking-at-rdrpidentifytargetprocess">Looking at <em>RdrpIdentifyTargetProcess</em></h2>
<p>What happens if the Memory Leak Diagnoser is triggered, and there are multiple processes with a high enough amount of committed memory to be diagnosed? Well, only one of them is chosen to be registered. I wanted to figure out how this choice is made, so the next function I looked at was <em>RdrpIdentifyTargetProcess</em>.</p>
<p>First, it calls <em>RdrpGetProcessInformation</em>, which in turn uses the <em>NtQuerySystemInformation</em> API call; this time - to get an array of <em>SYSTEM_PROCESS_INFORMATION</em> structures, one for each running process:</p>
<p><img loading="lazy" src="images/ida32_process_list.png" alt=""  />
</p>
<p>These structures contain information about the resource usage of each process. Later, it seems like this array is sorted by the amount of committed memory in each process:</p>
<p><img loading="lazy" src="images/ida32_qsort.png" alt=""  />
</p>
<h2 id="answering-my-research-questions">Answering my Research Questions</h2>
<p>At this point, I had a <del>solid and complete</del> theory, which I have tested and verified:</p>
<p>The Memory Leak Diagnoser is triggered every <em>TimerInverval</em> minutes. When triggered, it gets a list of all running processes, and sorts them by their amount of committed memory (in descending order). Then, it chooses the first process on the list which:</p>
<ul>
<li>Has committed at least <em>CommitThreshold</em> percent out of the total amount of physical memory installed.</li>
<li>Wasn&rsquo;t already chosen in the last <em>DetectionInterval</em> days.</li>
</ul>
<p>A sub-key beneath the <em>DiagnosedApplications</em> key is then created (if it doesn&rsquo;t exist already) for the chosen process, and the <em>LastDetectionTime</em> is updated.</p>
<p><strong>Edit:</strong> some built-in executables are chosen to be diagnosed, but are not registered.<br>
Why? Further research is needed.</p>
<h2 id="closing-thoughts">Closing Thoughts</h2>
<p>That&rsquo;s all! I hope you found this short research interesting. This artifact is not all that powerful, because only the applications that commit a large amount of memory are registered. Nonetheless, it was quite fun to research. I&rsquo;m not super experienced in using IDA and reverse engineering, but I think I did a decent job. Let me know what you think!</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Resolving File Paths Using the MFT</title>
      <link>https://harelsegev.github.io/posts/resolving-file-paths-using-the-mft/</link>
      <pubDate>Thu, 07 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://harelsegev.github.io/posts/resolving-file-paths-using-the-mft/</guid>
      <description>In NTFS, the MFT (Master File Table) is a structure that contains a lot of the file-system metadata, and also the contents of small files. It is stored in a special file, called $MFT. In incident response, we often collect and parse this file to determine the file system contents and how it changed over time, without having to acquire a full disk image.
There are many bad MFT parsers out there.</description>
      <content:encoded><![CDATA[<p>In NTFS, the MFT (Master File Table) is a structure that contains a lot of the file-system metadata, and also the contents of small files. It is stored in a special file, called <code>$MFT</code>. In incident response, we often collect and parse this file to determine the file system contents and how it changed over time, without having to acquire a full disk image.</p>
<p>There are many bad MFT parsers out there. This is no coincidence - an MFT parser is an extremely easy thing to mess up. Most MFT parsers don&rsquo;t bother handling the uncommon edge cases - and they work fine, most of the times. The fact is, some of those uncommon edge cases are actually more common than you would think. Handling them correctly is what sets the good MFT parsers apart from the bad ones.</p>
<p>The MFT is an array of  file records - each one describes a file on the system. File records do not to store directory hierarchy, though. There&rsquo;s another structure for that - directory indexes. The directory index a file is listed in determines its location in the directory tree. The directory index is the one storing the name of the file, inside a structure called a <code>$FILE_NAME</code> attribute.</p>
<p>Reconstructing full file paths using only the MFT is not trivial. Whether it is a reliable method at all is debatable. It is only possible because of an NTFS quirk - There&rsquo;s a backup of every file&rsquo;s <code>$FILE_NAME</code> attribute inside its MFT record. Nonetheless, this method is simple, fast, and is often good enough. In this post, I&rsquo;ll help you avoid its common implementation pitfalls.</p>
<h2 id="before-we-start">Before we Start</h2>
<p>Given a <code>$MFT</code> file, we first have to determine the size of an individual file record. It&rsquo;s usually 1024 bytes, but it doesn&rsquo;t have to be. This value is stored in the file system boot sector - which we don&rsquo;t have. Instead, we can find any two consecutive file records, and calculate the difference between their offsets. This should give us the size of a file record.</p>
<p>Another thing to consider, is that file records, like other important file system structures, use <a href="https://flatcap.github.io/linux-ntfs/ntfs/concepts/fixup.html">fixup values</a> to detect disk errors. If you ignore fixup values, your parser will output incorrect data, and the worst part is - you are probably not going to notice. Take my word for it, and start writing the code to deal with fixup values early on.</p>
<h2 id="a-naive--approach">A Naive  Approach</h2>
<p>This is the structure of a <code>$FILE_NAME</code> attribute:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>6</td>
<td style="text-align:left">Parent index</td>
</tr>
<tr>
<td>0x06</td>
<td>2</td>
<td style="text-align:left">Parent sequence</td>
</tr>
<tr>
<td>0x08</td>
<td>8</td>
<td style="text-align:left">Creation time</td>
</tr>
<tr>
<td>0x10</td>
<td>8</td>
<td style="text-align:left">Modification time</td>
</tr>
<tr>
<td>0x18</td>
<td>8</td>
<td style="text-align:left">MFT record change time</td>
</tr>
<tr>
<td>0x20</td>
<td>8</td>
<td style="text-align:left">Access time</td>
</tr>
<tr>
<td>0x28</td>
<td>8</td>
<td style="text-align:left">Allocated size</td>
</tr>
<tr>
<td>0x30</td>
<td>8</td>
<td style="text-align:left">Real size</td>
</tr>
<tr>
<td>0x38</td>
<td>4</td>
<td style="text-align:left">Flags</td>
</tr>
<tr>
<td>0x3C</td>
<td>4</td>
<td style="text-align:left">Used by EAs and Reparse</td>
</tr>
<tr>
<td>0x40</td>
<td>1</td>
<td style="text-align:left">Filename length in bytes / 2 (L)</td>
</tr>
<tr>
<td>0x41</td>
<td>1</td>
<td style="text-align:left">Filename namespace</td>
</tr>
<tr>
<td>0x42</td>
<td>2L</td>
<td style="text-align:left">Filename in Unicode (not null terminated)</td>
</tr>
</tbody>
</table>
<p>As mentioned earlier, each file has a <code>$FILE_NAME</code> attribute inside its MFT record. For now, we&rsquo;re only interested in these 2 fields:</p>
<ul>
<li>
<p><code>Filename</code><br>
The name of the file described by the record.</p>
</li>
<li>
<p><code>Parent index</code><br>
An index to the MFT record of the file&rsquo;s parent folder.</p>
</li>
</ul>
<p>Using these fields, we can build the full path of a file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>                +--------------+
</span></span><span style="display:flex;"><span>    +----------&gt;| .            |    4. .\Documents\PDF\document.pdf
</span></span><span style="display:flex;"><span>    |           +--------------+        
</span></span><span style="display:flex;"><span>    |  +-------&gt;| Documents    |    3. Documents\PDF\document.pdf
</span></span><span style="display:flex;"><span>    +--|--------+--------------+
</span></span><span style="display:flex;"><span>       |        |              |
</span></span><span style="display:flex;"><span>       |        +--------------+
</span></span><span style="display:flex;"><span>       |  +----&gt;| PDF          |    2. PDF\document.pdf
</span></span><span style="display:flex;"><span>       +--|-----+--------------+
</span></span><span style="display:flex;"><span>          |     |              |
</span></span><span style="display:flex;"><span>          |     +--------------+
</span></span><span style="display:flex;"><span>          |     |              |
</span></span><span style="display:flex;"><span>          |     +--------------+
</span></span><span style="display:flex;"><span>          |     | document.pdf |    1. document.pdf
</span></span><span style="display:flex;"><span>          +-----+--------------+
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In NTFS, &#34;.&#34; is the file name of the root directory.
</span></span></code></pre></div><p>By looping over the MFT records, we can do this for every file on the system. Here&rsquo;s a Python-style pseudo code of the algorithm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    print(build_path(mft, current_record))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path</span>(mft, current_record):
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> is_root_directory(current_record):
</span></span><span style="display:flex;"><span>        filename_attribute <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_attribute(<span style="color:#e6db74">&#34;$FILE_NAME&#34;</span>)
</span></span><span style="display:flex;"><span>        path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Filename&#34;</span>) <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>        current_record <span style="color:#f92672">=</span> mft<span style="color:#f92672">.</span>get_record_at(filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent index&#34;</span>))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> path
</span></span></code></pre></div><p>Of course, we could have used caching to improve the efficiency - but for the sake of simplicity, all of the code in this post will be pretty inefficient. In the next sections, we&rsquo;ll see how deleted files, hard links and extension records break everything, and we&rsquo;ll change our code to deal with them.</p>
<h2 id="pitfall-1-orphan-files--the-sequence-number">Pitfall 1: Orphan Files &amp; the Sequence Number</h2>
<p>The first edge case we&rsquo;ll discuss involves deleted files. When a file is deleted, its MFT record is marked as free. Then, it can be reused if a new file is created - why add a new record to the MFT when there&rsquo;s a free, existing one? If there are multiple free records, and a new file is created - it may occupy either one of them.</p>
<p>We can tell whether a record is in use by looking at the <code>Flags</code> field in the record header, and more specifically - at its least significant bit, which is the flag representing the state of the record. When a record is allocated to a file, it is set. When that file is deleted, it is turned off.</p>
<h3 id="orphan-files">Orphan Files</h3>
<p>As long as the record of a deleted file is not reused - it remains intact, which means we can resolve the file&rsquo;s path just like any other file. Problems may arise if the file&rsquo;s parent folder is deleted as well. Let&rsquo;s see what happens when the parent folder&rsquo;s record is reused, while the child&rsquo;s record remains free:</p>
<ol>
<li>
<p>Folder1 is created. It occupies the MFT record at index 41</p>
<table>
<thead>
<tr>
<th>Record state</th>
<th>Record index</th>
<th>Reconstructed file path</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>In use</code></td>
<td>41</td>
<td>.\Folder1</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>File1.txt is created inside Folder1. It occupies the MFT record at index 42</p>
<table>
<thead>
<tr>
<th>Record state</th>
<th>Record index</th>
<th>Reconstructed file path</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>In use</code></td>
<td>41</td>
<td>.\Folder1</td>
</tr>
<tr>
<td><code>In use</code></td>
<td>42</td>
<td>.\Folder1\File1.txt</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Folder1 is deleted. File1.txt is in Folder1, so it is also deleted</p>
<table>
<thead>
<tr>
<th>Record state</th>
<th>Record index</th>
<th>Reconstructed file path</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Free</code></td>
<td>41</td>
<td>.\Folder1</td>
</tr>
<tr>
<td><code>Free</code></td>
<td>42</td>
<td>.\Folder1\File1.txt</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Folder2 is created. It occupies the MFT record at index 41</p>
<table>
<thead>
<tr>
<th>Record state</th>
<th>Record index</th>
<th>Reconstructed file path</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>In use</code></td>
<td>41</td>
<td>.\Folder2.txt</td>
</tr>
<tr>
<td><code>Free</code></td>
<td>42</td>
<td>.\Folder2\File1.txt</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>File1.txt was never in Folder2!</p>
<p>Deleted files their parent folder&rsquo;s record was reused are called <em>Orphan Files</em>. They were once created in some folder, but it is now gone. their original path cannot be resolved. A folder can be orphan too, which will make it the root of an orphan sub-tree. The hierarchy of the files inside an orphan sub-tree can be reconstructed, but it&rsquo;s detached from the main directory tree. the original path of the root of the sub-tree, which is an orphan folder, cannot be resolved.</p>
<h3 id="the-sequence-number">The Sequence Number</h3>
<p>On its own, an MFT index is not enough to reference a file. It references a record, which can be reused to describe many files over time. We don&rsquo;t want to reference records, we want to reference the files they describe. To reference a file, not only do we need to know its MFT index, but also whether the record in that index still belongs to it, or has been reused since.</p>
<p>This is where the sequence number comes in. It is stored in the record header, and is used together with the MFT index to reference files. That&rsquo;s why together, they are called a <em>File Reference</em>. Every time a record is <strong>freed</strong>, its sequence number is increased by 1. Then, any file references with the old sequence number are considered invalid.</p>
<p>Here&rsquo;s a pseudo-code of a reference validation function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_valid_file_reference</span>(mft, mft_index, sequence_number):
</span></span><span style="display:flex;"><span>	file_record <span style="color:#f92672">=</span> mft<span style="color:#f92672">.</span>get_record_at(mft_index)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> file_record<span style="color:#f92672">.</span>is_used():
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">return</span> file_record<span style="color:#f92672">.</span>get_sequence_number() <span style="color:#f92672">==</span> sequence_number
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># the sequence number was increased when the record was freed, </span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># so we should decrease it to get the actual sequence number of the file</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> file_record<span style="color:#f92672">.</span>get_sequence_number() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> sequence_number
</span></span></code></pre></div><p>Look again at the structure of the <code>$FILE_NAME</code> attribute. Not only do we have the MFT index of the parent folder, but also its sequence number. In other words - we have a file reference to the parent folder. This is exactly what we need to identify orphan files - all we need to do is validate this reference. If it&rsquo;s not valid, it means the parent folder was deleted, and its record was reused.</p>
<p>Now that we can identify orphan files, we have to decide how our code should deal with them. We could output the filenames and paths separately, and just not output a path for them. Or maybe we can place them all in some special folder, but which one? There&rsquo;s no folder it would be right to place them in. The solution we&rsquo;ll go with is quite simple: we&rsquo;ll just create a new folder for them.</p>
<p>Of course, it won&rsquo;t be an actual file system folder - we cannot create these. Nevertheless, we are the ones building the directory tree, so we can just &ldquo;make up&rdquo; a folder. It would be a &ldquo;virtual folder&rdquo;, if you will. We&rsquo;ll call it &ldquo;$OrphanFiles&rdquo; and place it in the root directory. Now we have a foster parent for all the orphan files!</p>
<p>Here&rsquo;s our upgraded code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    print(build_path(mft, current_record))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path</span>(mft, current_record):
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> is_root_directory(current_record):
</span></span><span style="display:flex;"><span>        filename_attribute <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_attribute(<span style="color:#e6db74">&#34;$FILE_NAME&#34;</span>)
</span></span><span style="display:flex;"><span>        path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Filename&#34;</span>) <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>        current_record <span style="color:#f92672">=</span> mft<span style="color:#f92672">.</span>get_record_at(filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent index&#34;</span>))
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>        sequence_number <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_sequence_number()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> current_record<span style="color:#f92672">.</span>is_used():
</span></span><span style="display:flex;"><span>            sequence number <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> sequence_number <span style="color:#f92672">!=</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent sequence&#34;</span>):
</span></span><span style="display:flex;"><span>            path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">$OrphanFiles&#34;</span> <span style="color:#f92672">+</span> path 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> path
</span></span></code></pre></div><h2 id="pitfall-2-hard-links-and-short-names">Pitfall 2: Hard Links and Short Names</h2>
<h3 id="hard-links">Hard Links</h3>
<p>Hard links are an often overlooked feature of NTFS. They are similar in functionality to the hard links in other file systems - a file can be located in multiple folders at the same time, and can have a different name in each one. Each directory index a file is located in stores a <code>$FILE_NAME</code> attribute for it. Fortunately for us, we have copies of all of these <code>$FILE_NAME</code> attributes in the file&rsquo;s MFT record.</p>
<p>This means a file can have multiple paths. To be exact, a file can have multiple hard links, and each one of <em>them</em> has a path. Each hard link has its own <code>$FILE_NAME</code>  attribute, containing its own file name and parent folder. To build all of the paths for a file, we&rsquo;ll loop over every <code>$FILE_NAME</code> attribute in its MFT record, and use them to build the path of each hard link separately.</p>
<p>Folders are easier to handle, because NTFS does not allow multiple hard links for them - it would allow you to create loops in the directory tree, and nobody wants that. This means a folder has only a single path. A hard link has a single parent folder - so it also has a single path. This means we&rsquo;ll build the path of each hard link very similarly to how we did it previously.</p>
<h3 id="short-names">Short Names</h3>
<p>Short file names (SFNs) are a special type of hard links. If enabled, they&rsquo;re created automatically for files their names are too long to be handled by some old applications. They provide these old applications with an auto-generated, shorter file name they can handle. A short name is created in the same directory with the original hard link, and we can build the path for it the same way we do for a regular hard link.</p>
<p>We can tell whether a <code>$FILE_NAME</code> attribute contains a short name by checking its <em>Filename namespace</em> flag. A <code>DOS</code> namespace means it&rsquo;s a short name, and a <code>WIN32</code> or a <code>POSIX</code> namespace means it&rsquo;s a regular, long name. <code>WIN32 &amp; DOS</code> is a special value indicating there is no short name for the file, because its name is already a valid short name.</p>
<p>Folders cannot have regular hard links, but they can have short names. This is a problem - if folders can have 2 different names, it means a hard link can have a huge number of different paths. Suppose a hard link is <code>n</code> folders deep in the directory tree, and each folder has 2 names at most - long and short, excluding the root directory, a hard link has at most <code>2ⁿ⁻¹</code> different paths!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>. \ ??? \ ??? \ ??? \ .... \ File.txt
</span></span><span style="display:flex;"><span>     x2    x2    x2    ....
</span></span></code></pre></div><p>To keep things reasonable, we&rsquo;ll only use the long name of each folder to build the path of a hard link. By doing so, we&rsquo;re in fact choosing a single path for it, out of the many it may have. We can get away with it, because we build the paths for the folders in the exact same way. Each folder&rsquo;s short name is also a hard link, and we&rsquo;ll build a path for it when we get to that folder&rsquo;s MFT record. We&rsquo;re not loosing any short names.</p>
<p>Long names with the same prefix will have similar short names generated for them. It&rsquo;s important to output the MFT index of each path, so we can tell which short name belongs to which long name:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>MFT Index    Path
</span></span><span style="display:flex;"><span>59:			.\Program Files
</span></span><span style="display:flex;"><span>1293:		.\ProgramData
</span></span><span style="display:flex;"><span>59:			.\PROGRA~1
</span></span><span style="display:flex;"><span>1293:		.\PROGRA~2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PROGRA~1 --&gt; Program Files
</span></span><span style="display:flex;"><span>PROGRA~2 --&gt; ProgramData
</span></span></code></pre></div><p>This is the upgraded code. It now handles hard links, and outputs both long and short names:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    build_path(mft, current_record)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path</span>(mft, current_record):
</span></span><span style="display:flex;"><span>	mft_index <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_mft_index()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> filename_attribute <span style="color:#f92672">in</span> current_record<span style="color:#f92672">.</span>get_filename_attributes():
</span></span><span style="display:flex;"><span>        print(mft_index <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">+</span> build_path_helper(mft, filename_attribute))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path_helper</span>(mft, filename_attribute):
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Filename&#34;</span>) <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>        parent_record <span style="color:#f92672">=</span> mft<span style="color:#f92672">.</span>get_record_at(filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent index&#34;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> is_root_directory(parent_record):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        parent_sequence <span style="color:#f92672">=</span> parent_record<span style="color:#f92672">.</span>get_sequence_number()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> parent_record<span style="color:#f92672">.</span>is_used():
</span></span><span style="display:flex;"><span>            parent_sequence <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> parent_sequence <span style="color:#f92672">!=</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent sequence&#34;</span>):
</span></span><span style="display:flex;"><span>            path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">$OrphanFiles&#34;</span> <span style="color:#f92672">+</span> path 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        filename_attribute <span style="color:#f92672">=</span> next(get_lfn_filename_attributes(parent_record))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Get only filename attributes with a Long File Name (LFN)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_lfn_filename_attributes</span>(file_record):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> filename_attribute <span style="color:#f92672">in</span> file_record<span style="color:#f92672">.</span>get_filename_attributes():
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Name space&#34;</span>) <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;DOS&#34;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield</span> filename_attribute
</span></span></code></pre></div><p>If you don&rsquo;t care about the short names, you don&rsquo;t have to build paths for them. You can simply ignore them altogether. That&rsquo;s perfectly fine, but I believe it&rsquo;s better to output both long and short names - and group them into a single event, later in the analysis phase. To ignore short names, all we need is a small modification to the <code>build_path</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path</span>(mft, current_record):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> filename_attribute <span style="color:#f92672">in</span> get_lfn_filename_attributes(current_record):
</span></span><span style="display:flex;"><span>        print build_path_helper(mft, filename_attribute)
</span></span></code></pre></div><h2 id="pitfall-3-extension-records-missing-attributes-and-orphaned-attributes">Pitfall 3: Extension Records, Missing Attributes and Orphaned Attributes</h2>
<h3 id="extension-records">Extension Records</h3>
<p>If a file becomes extremely large and fragmented, or has many hard links, a single file record may not be big enough to contain all of its attributes. In such case, the file will occupy additional file records. The file&rsquo;s main record is called the <em>Base Record</em>, and the additional ones are called <em>Extension Records</em>. When some of a file&rsquo;s attributes are stored in extension records, its base record contains a special attribute, called <code>$ATTRIBUTE_LIST</code>, which stores the information needed to find them.</p>
<p>Some MFT parsers use the <code>$ATTRIBUTE_LIST</code> attribute in the base record to find its extension records. This is a major mistake, because <code>$ATTRIBUTE_LIST</code> attributes can be non-resident (stored outside the MFT). Instead, we&rsquo;ll take the opposite approach - find the extension records, and trace them back to their base record.</p>
<p>Conveniently, the file-record header contains a <code>Base index</code> and <code>Base sequence</code> fields, to store a file reference to the base record. In base records, these fields are zeroed out. This means we can also use them to differentiate base records from extension records, without having to check for a <code>$ATTRIBUTE_LIST</code> attribute.</p>
<p>By looping over the MFT, we can create a mapping of base records to extension records:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#75715e"># a dictionay to map base records to their extension records</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mappings are of the form: (n, m) -&gt; [k1, k2, ...], where:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># (n, m) is a file reference of a base record</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ki is the MFT index of an extension record</span>
</span></span><span style="display:flex;"><span>extension_records <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_base_record(current_record):
</span></span><span style="display:flex;"><span>        base_index <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_base_record_index()
</span></span><span style="display:flex;"><span>        base_sequence <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_base_record_sequence()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        (extension_records
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>setdefault((base_index, base_sequence), [])
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>append(current_record<span style="color:#f92672">.</span>get_mft_index()))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_base_record</span>(current_record):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (current_record<span style="color:#f92672">.</span>get_base_record_index() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>            current_record<span style="color:#f92672">.</span>get_base_record_sequeunce() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p>After we create this dictionary, we have to loop over the MFT one more time. This time, looking for base records. For each base record, we will build a path for all the <code>$FILE_NAME</code> attributes both in it, and in its extension records - if it has any.</p>
<h3 id="missing-attributes">Missing Attributes</h3>
<p>As always, deleted files create problems. When a file is deleted, its base record and all of its extension records are marked as free. The problem is - all of those free records are not going to be reused all at the same time. If some, but not all of the file&rsquo;s records are reused - we loose some, but not all of the file&rsquo;s attributes. This has major consequences on MFT parsing in general, and on path reconstruction in particular.</p>
<p>We may find a file without any <code>$FILE_NAME</code> attributes. For such a file, path reconstruction is impossible. The best you can do is give it a unique identifier. You may be tempted to place it in the $OrphanFiles folder, but that wouldn&rsquo;t be right -  it&rsquo;s not necessarily orphan. Sure, it&rsquo;s deleted, but its parent folder might not be.</p>
<p>If you find a <strong>folder</strong> without any <code>$FILE_NAME</code> attributes, you may also find deleted files that were once inside it. Those files can be safely placed in the $OrphanFiles folder, because the folder is deleted, and we won&rsquo;t output a path for it.</p>
<h3 id="orphaned-attributes">Orphaned Attributes</h3>
<p>To resolve the parent folder for a file, we validate the parent reference in its <code>$FILE_NAME</code> attribute. If it&rsquo;s not valid, it means the file is orphan, right? Well, yes - but we can do better than that. Before declaring the file is orphan, we should check whether its parent has any extension records left. If there&rsquo;s a <code>$FILE_NAME</code> attribute in one of them, we can use it to resolve the file&rsquo;s path.</p>
<p>This is the final version of our code. It handles everything we talked about so far: orphan files, hard links and extension records:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#75715e"># a dictionay to map base records to their extension records</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mappings are of the form: (n, m) -&gt; [k1, k2, ...], where:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># (n, m) is a file reference of a base record</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ki is the MFT index of an extension record</span>
</span></span><span style="display:flex;"><span>extension_records <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># first pass over the MFT</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_base_record(current_record):
</span></span><span style="display:flex;"><span>        base_index <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_base_record_index()
</span></span><span style="display:flex;"><span>        base_sequence <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_base_record_sequence()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        (extension_records
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>setdefault((base_index, base_sequence), [])
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>append(current_record<span style="color:#f92672">.</span>get_mft_index()))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># second pass over the MFT</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> is_base_record(current_record):
</span></span><span style="display:flex;"><span>        build_path(mft, current_record)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_base_record</span>(current_record):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (current_record<span style="color:#f92672">.</span>get_base_record_index() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>            current_record<span style="color:#f92672">.</span>get_base_record_sequeunce() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path</span>(mft, current_record):    
</span></span><span style="display:flex;"><span>    base_filename_attributes <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_filename_attributes()
</span></span><span style="display:flex;"><span>    extension_filename_attributes <span style="color:#f92672">=</span> get_extension_filename_attributes(
</span></span><span style="display:flex;"><span>        current_record<span style="color:#f92672">.</span>get_mft_index(),
</span></span><span style="display:flex;"><span>        current_record<span style="color:#f92672">.</span>get_sequence_number()
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    mft_index <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_mft_index()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> filename_attribute <span style="color:#f92672">in</span> base_filename_attributes <span style="color:#f92672">+</span> extension_filename_attributes:
</span></span><span style="display:flex;"><span>    	print(mft_index <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">+</span> build_path_helper(mft, filename_attribute))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path_helper</span>(mft, filename_attribute):
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Filename&#34;</span>) <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>        parent_record <span style="color:#f92672">=</span> mft<span style="color:#f92672">.</span>get_record_at(filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent index&#34;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> is_root_directory(parent_record):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        parent_sequence <span style="color:#f92672">=</span> parent_record<span style="color:#f92672">.</span>get_sequence_number()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> parent_record<span style="color:#f92672">.</span>is_used():
</span></span><span style="display:flex;"><span>            parent_sequence <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        parent_filename_attributes <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if parent record still belongs to my parent, get its filename attributes</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> parent_sequence <span style="color:#f92672">==</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent sequence&#34;</span>):
</span></span><span style="display:flex;"><span>            parent_filename_attributes <span style="color:#f92672">=</span> parent_record<span style="color:#f92672">.</span>get_filename_attributes()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># get the filename attributes from any extension records of my parent</span>
</span></span><span style="display:flex;"><span>        parent_filename_attributes <span style="color:#f92672">+=</span> get_extension_filename_attributes(
</span></span><span style="display:flex;"><span>        	filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent index&#34;</span>),
</span></span><span style="display:flex;"><span>            filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent sequence&#34;</span>)
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> parent_filename_attributes:
</span></span><span style="display:flex;"><span>	        <span style="color:#75715e"># could not find a $FILE_NAME attribute of my parent</span>
</span></span><span style="display:flex;"><span>            path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">$OrphanFiles&#34;</span> <span style="color:#f92672">+</span> path 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># prioritize LFNs when choosing a name for the parent</span>
</span></span><span style="display:flex;"><span>        filename_attribute <span style="color:#f92672">=</span> max(parent_filename_attributes, key<span style="color:#f92672">=</span>get_priority)        
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_extension_filename_attributes</span>(base_index, base_sequence):
</span></span><span style="display:flex;"><span>    extension_records <span style="color:#f92672">=</span>  map(
</span></span><span style="display:flex;"><span>    	mft<span style="color:#f92672">.</span>get_record_at, 
</span></span><span style="display:flex;"><span>    	extension_records[(base_index, base_sequence)]
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    filename_attributes <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> record <span style="color:#f92672">in</span> extension_records:
</span></span><span style="display:flex;"><span>        filename_attributes <span style="color:#f92672">+=</span> record<span style="color:#f92672">.</span>get_filename_attributes()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> filename_attributes
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_priority</span>(filename_attribute):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Name space&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;DOS&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>In the previous version, we built paths using the long file name (LFN) of each folder, because the long names are more meaningful than the auto-generated short names. Now we know that the <code>$FILE_NAME</code> attribute containing the short name may be the only <code>$FILE_NAME</code> attribute left after some of a folder&rsquo;s records were reused.</p>
<p>In this new version, we prioritize the LFN <code>$FILE_NAME</code> attributes, but we will use the SFN <code>$FILE_NAME</code> attribute if it&rsquo;s the only one left.</p>
<h2 id="closing-thoughts">Closing Thoughts</h2>
<p>This post was my attempt to create the resource I wish I had when I wrote my MFT parser. MFT parsing is such a fundamental technique in forensics; yet, the resources to learn it are lacking. People have been writing MFT parsers for years, each one on their own, rediscovering the same edge cases and learning the same lessons again and again.</p>
<p>It really shouldn&rsquo;t be like that. I think we DFIR programmers have a lot to learn in sharing our knowledge with one another, so we can push the field forward, together.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Home Adventures! A Prefetch File in $I30 Slack, PyInstaller &amp; Prefetch Hash Cracking</title>
      <link>https://harelsegev.github.io/posts/home-adventures/home-adventures-a-prefetch-file-in-i30-slack-pyinstaller-prefetch-hash-cracking/</link>
      <pubDate>Sat, 02 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://harelsegev.github.io/posts/home-adventures/home-adventures-a-prefetch-file-in-i30-slack-pyinstaller-prefetch-hash-cracking/</guid>
      <description>I often test my tools on my old computer at home. It&amp;rsquo;s so much more interesting to investigate than a newly created virtual machine. Today, while testing, I found evidence of activity from almost 2 years ago. It got me really excited, and I thought it would make a cool blog post!
Here&amp;rsquo;s a snippet from the timeline I created using MFTECmd and INDXRipper:
A Prefetch File in $I30 Slack The Prefetch file FLOSS64.</description>
      <content:encoded><![CDATA[<p>I often test my tools on my old computer at home. It&rsquo;s so much more interesting to investigate than a newly created virtual machine. Today, while testing, I found evidence of activity from almost 2 years ago. It got me really excited, and I thought it would make a cool blog post!</p>
<p>Here&rsquo;s a snippet from the timeline I created using MFTECmd and INDXRipper:</p>
<p><img loading="lazy" src="images/timeline.jpg" alt=""  />
</p>
<h2 id="a-prefetch-file-in-i30-slack">A Prefetch File in $I30 Slack</h2>
<p>The Prefetch file <code>FLOSS64.EXE-F5F88991.pf</code> was created on September 10th 2020. Today is July 2nd 2022; almost 2 years have passed! There&rsquo;s no trace of this file in the MFT, nor in  $J - which goes only a week back. The only thing left proving this file once existed is a $I30 entry in slack space of the Prefetch folder.</p>
<p>This Prefetch file must have been created because I executed Floss, which is a tool from FireEye. But <code>floss64.exe</code> is not in the MFT or in $J. It&rsquo;s not in my timeline, meaning INDXRipper could not find it in $I30 of any directory. I parsed the ShimCache and AmCache, but there was nothing there either.</p>
<blockquote>
<p>The $I30 of the Prefetch folder is a forensic goldmine; The $I30s from the users&rsquo; Recent folders are also very valuable. When triaging a system, I usually collect the $I30s from such key folders, these are just a few examples:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>C:\Windows\Prefetch
</span></span><span style="display:flex;"><span>C:\Users\<span style="color:#f92672">*</span>\AppData\Roaming\Microsoft\Windows\Recent
</span></span><span style="display:flex;"><span>C:\ProgramData\Microsoft\Windows Defender\LocalCopy
</span></span><span style="display:flex;"><span>C:\Users\<span style="color:#f92672">*</span>\Downloads
</span></span><span style="display:flex;"><span>C:\PerfLogs
</span></span></code></pre></div><p>I use RawCopy to collect these; KAPE does not currently support $I30 collection.</p>
</blockquote>
<p>The Prefetch file was created at 23:14:57, probably right after <code>floss64.exe</code> was first executed. We can also see a last modification time at 23:25:35. If I were to find this Prefetch file in the MFT, and this last modification timestamp were from <code>$STANDATD_INFORMATION</code>, I would say that it indicates the last execution time of <code>floss64.exe</code>. However, this timestamp is from $I30 slack, so this might not be the case.</p>
<p>I know what you think - $I30 timestamps should mirror those in the <code>$STANDATD_INFORMATION</code> attribute! And you are absolutely right. But $I30 entries, as opposed to MFT entries, can move around throughout their lifetime. When a file is created or deleted in a directory, $I30 entries of other files in the directory may be unallocated, and then reallocated in a different place. This entry could have been unallocated while the Prefetch file was still active! In this case, the entry may contain outdated information.</p>
<h2 id="pyinstaller">PyInstaller</h2>
<p>Floss is written in Python, and is packaged with PyInstaller. Here&rsquo;s is a brief description of PyInstaller, straight from its manual:</p>
<blockquote>
<p>PyInstaller bundles a Python application and all its dependencies into a single package. The user can run the packaged app without installing a Python interpreter or any modules.</p>
</blockquote>
<p>There are also details about its inner workings:</p>
<blockquote>
<p>[&hellip;] The bootloader is the heart of the one-file bundle also. When started it creates a temporary folder in the appropriate temp-folder location for this OS. The folder is named <code>_MEI*xxxxxx*</code>, where <em>xxxxxx</em> is a random number. [&hellip;] The bootloader uncompresses the support files and writes copies into the temporary folder.</p>
</blockquote>
<p>At 23:28:52, The folder <code>_MEI86322</code> was created in my user&rsquo;s <code>Temp</code> directory, which indicates I executed a PyInstaller executable. INDXRipper was kind enough to parse the $I30 of this folder for us, so we can see a compiled python module (.pyd file) that was created inside the folder and deleted since.</p>
<p>My guess is that <code>floss64.exe</code> was first executed at 23:14:57, then executed again at 23:25:35, and then again at 23:28:52. The $I30 entry we found in slack space was unallocated somewhere between 23:25:35 and 23:28:52, so the last modification time wasn&rsquo;t updated the next time <code>floss64.exe</code> was executed.</p>
<p>An interesting thing to note, is that we only see a single <code>_MEI*xxxxxx*</code> folder; yet, we know a unique one should have been created for every execution of <code>floss64.exe</code>.</p>
<blockquote>
<p>When the bundled code terminates, the bootloader deletes the temporary folder. [&hellip;] The <code>_MEI*xxxxxx*</code> folder is not removed if the program crashes or is killed</p>
</blockquote>
<p>This is interesting! The folder <code>_MEI86322</code> is not deleted, so <code>floss64.exe</code> might have crashed after it was executed at 23:28:52. I looked for an error report, but couldn&rsquo;t find one.</p>
<h2 id="prefetch-hash-cracking">Prefetch Hash Cracking</h2>
<p>Can we find the folder from which <code>floss64.exe</code> was executed? Unfortunately, ShimCache and AmCache aren&rsquo;t much help this time. A cool thing we can try is to brute-force the Prefetch hash; i.e, hashing possible full paths of <code>floss64.exe</code> until the result matches the Prefetch hash, which is <code>F5F88991</code>. I wrote a little tool to do this for me; I just have to give it the bodyfile I used to create the timeline, so it can enumerate all the folders <code>floss64.exe</code> might have been executed from:</p>
<p><img loading="lazy" src="images/hash_cracker.jpg" alt=""  />
</p>
<p>This doesn&rsquo;t always work, but this time it did! <code>floss64.exe</code> was executed from the Forensics directory on the C: drive.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p>That&rsquo;s it for this post! I wanted to demonstrate both the value and the subtleties of $I30 analysis; let me know if you found that educational. Also, I&rsquo;m no expert; If you think I got something wrong, please tell me. Home Adventures may become a series if I find the time for it. I may also write a detailed post about INDXRipper; Let me know if you&rsquo;d be interested in that!</p>
<h3 id="tool-list">Tool List</h3>
<table>
<thead>
<tr>
<th>Tool</th>
<th>Source</th>
</tr>
</thead>
<tbody>
<tr>
<td>MFTECmd</td>
<td><a href="https://github.com/EricZimmerman/MFTECmd">https://github.com/EricZimmerman/MFTECmd</a></td>
</tr>
<tr>
<td>INDXRipper</td>
<td><a href="https://github.com/harelsegev/INDXRipper">https://github.com/harelsegev/INDXRipper</a></td>
</tr>
<tr>
<td>Prefetch Hash Cracker</td>
<td><a href="https://github.com/harelsegev/prefetch-hash-cracker">https://github.com/harelsegev/prefetch-hash-cracker</a></td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
