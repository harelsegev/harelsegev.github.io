<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Resolving File Paths Using the MFT | RAT In Mi Kitchen</title>
<meta name="keywords" content="NTFS, MFT">
<meta name="description" content="In NTFS, the MFT (Master File Table) is a structure that contains a lot of the file-system metadata, and also the contents of small files. It is stored in a special file, called $MFT. In incident response, we often collect and parse this file to determine the file system contents and how it changed over time, without having to acquire a full disk image.
There are many bad MFT parsers out there.">
<meta name="author" content="Harel Segev">
<link rel="canonical" href="https://harelsegev.github.io/posts/resolving-file-paths-using-the-mft/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.0b739a2e2c5e5656e4bcd5f0b2268d063addaf81d89ec3987d6af8f04decdc97.css" integrity="sha256-C3OaLixeVlbkvNXwsiaNBjrdr4HYnsOYfWr48E3s3Jc=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://harelsegev.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://harelsegev.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://harelsegev.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://harelsegev.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://harelsegev.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Resolving File Paths Using the MFT" />
<meta property="og:description" content="In NTFS, the MFT (Master File Table) is a structure that contains a lot of the file-system metadata, and also the contents of small files. It is stored in a special file, called $MFT. In incident response, we often collect and parse this file to determine the file system contents and how it changed over time, without having to acquire a full disk image.
There are many bad MFT parsers out there." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://harelsegev.github.io/posts/resolving-file-paths-using-the-mft/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-07T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-07-07T00:00:00&#43;00:00" /><meta property="og:site_name" content="RAT In Mi Kitchen" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Resolving File Paths Using the MFT"/>
<meta name="twitter:description" content="In NTFS, the MFT (Master File Table) is a structure that contains a lot of the file-system metadata, and also the contents of small files. It is stored in a special file, called $MFT. In incident response, we often collect and parse this file to determine the file system contents and how it changed over time, without having to acquire a full disk image.
There are many bad MFT parsers out there."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://harelsegev.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Resolving File Paths Using the MFT",
      "item": "https://harelsegev.github.io/posts/resolving-file-paths-using-the-mft/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Resolving File Paths Using the MFT",
  "name": "Resolving File Paths Using the MFT",
  "description": "In NTFS, the MFT (Master File Table) is a structure that contains a lot of the file-system metadata, and also the contents of small files. It is stored in a special file, called $MFT. In incident response, we often collect and parse this file to determine the file system contents and how it changed over time, without having to acquire a full disk image.\nThere are many bad MFT parsers out there.",
  "keywords": [
    "NTFS", "MFT"
  ],
  "articleBody": "In NTFS, the MFT (Master File Table) is a structure that contains a lot of the file-system metadata, and also the contents of small files. It is stored in a special file, called $MFT. In incident response, we often collect and parse this file to determine the file system contents and how it changed over time, without having to acquire a full disk image.\nThere are many bad MFT parsers out there. This is no coincidence - an MFT parser is an extremely easy thing to mess up. Most MFT parsers don’t bother handling the uncommon edge cases - and they work fine, most of the times. The fact is, some of those uncommon edge cases are actually more common than you would think. Handling them correctly is what sets the good MFT parsers apart from the bad ones.\nThe MFT is an array of file records - each one describes a file on the system. File records do not to store directory hierarchy, though. There’s another structure for that - directory indexes. The directory index a file is listed in determines its location in the directory tree. The directory index is the one storing the name of the file, inside a structure called a $FILE_NAME attribute.\nReconstructing full file paths using only the MFT is not trivial. Whether it is a reliable method at all is debatable. It is only possible because of an NTFS quirk - There’s a backup of every file’s $FILE_NAME attribute inside its MFT record. Nonetheless, this method is simple, fast, and is often good enough. In this post, I’ll help you avoid its common implementation pitfalls.\nBefore we Start Given a $MFT file, we first have to determine the size of an individual file record. It’s usually 1024 bytes, but it doesn’t have to be. This value is stored in the file system boot sector - which we don’t have. Instead, we can find any two consecutive file records, and calculate the difference between their offsets. This should give us the size of a file record.\nAnother thing to consider, is that file records, like other important file system structures, use fixup values to detect disk errors. If you ignore fixup values, your parser will output incorrect data, and the worst part is - you are probably not going to notice. Take my word for it, and start writing the code to deal with fixup values early on.\nA Naive Approach This is the structure of a $FILE_NAME attribute:\nOffset Size Description 0x00 6 Parent index 0x06 2 Parent sequence 0x08 8 Creation time 0x10 8 Modification time 0x18 8 MFT record change time 0x20 8 Access time 0x28 8 Allocated size 0x30 8 Real size 0x38 4 Flags 0x3C 4 Used by EAs and Reparse 0x40 1 Filename length in bytes / 2 (L) 0x41 1 Filename namespace 0x42 2L Filename in Unicode (not null terminated) As mentioned earlier, each file has a $FILE_NAME attribute inside its MFT record. For now, we’re only interested in these 2 fields:\nFilename\nThe name of the file described by the record.\nParent index\nAn index to the MFT record of the file’s parent folder.\nUsing these fields, we can build the full path of a file:\n+--------------+ +----------\u003e| . | 4. .\\Documents\\PDF\\document.pdf | +--------------+ | +-------\u003e| Documents | 3. Documents\\PDF\\document.pdf +--|--------+--------------+ | | | | +--------------+ | +----\u003e| PDF | 2. PDF\\document.pdf +--|-----+--------------+ | | | | +--------------+ | | | | +--------------+ | | document.pdf | 1. document.pdf +-----+--------------+ In NTFS, \".\" is the file name of the root directory. By looping over the MFT records, we can do this for every file on the system. Here’s a Python-style pseudo code of the algorithm:\nfor current_record in mft.get_records(): print(build_path(mft, current_record)) def build_path(mft, current_record): path = \"\" while not is_root_directory(current_record): filename_attribute = current_record.get_attribute(\"$FILE_NAME\") path = \"\\\\\" + filename_attribute.get_field(\"Filename\") + path current_record = mft.get_record_at(filename_attribute.get_field(\"Parent index\")) return \".\" + path Of course, we could have used caching to improve the efficiency - but for the sake of simplicity, all of the code in this post will be pretty inefficient. In the next sections, we’ll see how deleted files, hard links and extension records break everything, and we’ll change our code to deal with them.\nPitfall 1: Orphan Files \u0026 the Sequence Number The first edge case we’ll discuss involves deleted files. When a file is deleted, its MFT record is marked as free. Then, it can be reused if a new file is created - why add a new record to the MFT when there’s a free, existing one? If there are multiple free records, and a new file is created - it may occupy either one of them.\nWe can tell whether a record is in use by looking at the Flags field in the record header, and more specifically - at its least significant bit, which is the flag representing the state of the record. When a record is allocated to a file, it is set. When that file is deleted, it is turned off.\nOrphan Files As long as the record of a deleted file is not reused - it remains intact, which means we can resolve the file’s path just like any other file. Problems may arise if the file’s parent folder is deleted as well. Let’s see what happens when the parent folder’s record is reused, while the child’s record remains free:\nFolder1 is created. It occupies the MFT record at index 41\nRecord state Record index Reconstructed file path In use 41 .\\Folder1 File1.txt is created inside Folder1. It occupies the MFT record at index 42\nRecord state Record index Reconstructed file path In use 41 .\\Folder1 In use 42 .\\Folder1\\File1.txt Folder1 is deleted. File1.txt is in Folder1, so it is also deleted\nRecord state Record index Reconstructed file path Free 41 .\\Folder1 Free 42 .\\Folder1\\File1.txt Folder2 is created. It occupies the MFT record at index 41\nRecord state Record index Reconstructed file path In use 41 .\\Folder2.txt Free 42 .\\Folder2\\File1.txt File1.txt was never in Folder2!\nDeleted files their parent folder’s record was reused are called Orphan Files. They were once created in some folder, but it is now gone. their original path cannot be resolved. A folder can be orphan too, which will make it the root of an orphan sub-tree. The hierarchy of the files inside an orphan sub-tree can be reconstructed, but it’s detached from the main directory tree. the original path of the root of the sub-tree, which is an orphan folder, cannot be resolved.\nThe Sequence Number On its own, an MFT index is not enough to reference a file. It references a record, which can be reused to describe many files over time. We don’t want to reference records, we want to reference the files they describe. To reference a file, not only do we need to know its MFT index, but also whether the record in that index still belongs to it, or has been reused since.\nThis is where the sequence number comes in. It is stored in the record header, and is used together with the MFT index to reference files. That’s why together, they are called a File Reference. Every time a record is freed, its sequence number is increased by 1. Then, any file references with the old sequence number are considered invalid.\nHere’s a pseudo-code of a reference validation function:\ndef is_valid_file_reference(mft, mft_index, sequence_number): file_record = mft.get_record_at(mft_index) if file_record.is_used(): return file_record.get_sequence_number() == sequence_number else: # the sequence number was increased when the record was freed, # so we should decrease it to get the actual sequence number of the file return file_record.get_sequence_number() - 1 == sequence_number Look again at the structure of the $FILE_NAME attribute. Not only do we have the MFT index of the parent folder, but also its sequence number. In other words - we have a file reference to the parent folder. This is exactly what we need to identify orphan files - all we need to do is validate this reference. If it’s not valid, it means the parent folder was deleted, and its record was reused.\nNow that we can identify orphan files, we have to decide how our code should deal with them. We could output the filenames and paths separately, and just not output a path for them. Or maybe we can place them all in some special folder, but which one? There’s no folder it would be right to place them in. The solution we’ll go with is quite simple: we’ll just create a new folder for them.\nOf course, it won’t be an actual file system folder - we cannot create these. Nevertheless, we are the ones building the directory tree, so we can just “make up” a folder. It would be a “virtual folder”, if you will. We’ll call it “$OrphanFiles” and place it in the root directory. Now we have a foster parent for all the orphan files!\nHere’s our upgraded code:\nfor current_record in mft.get_records(): print(build_path(mft, current_record)) def build_path(mft, current_record): path = \"\" while not is_root_directory(current_record): filename_attribute = current_record.get_attribute(\"$FILE_NAME\") path = \"\\\\\" + filename_attribute.get_field(\"Filename\") + path current_record = mft.get_record_at(filename_attribute.get_field(\"Parent index\")) sequence_number = current_record.get_sequence_number() if not current_record.is_used(): sequence number -= 1 if sequence_number != filename_attribute.get_field(\"Parent sequence\"): path = \"\\\\$OrphanFiles\" + path break return \".\" + path Pitfall 2: Hard Links and Short Names Hard Links Hard links are an often overlooked feature of NTFS. They are similar in functionality to the hard links in other file systems - a file can be located in multiple folders at the same time, and can have a different name in each one. Each directory index a file is located in stores a $FILE_NAME attribute for it. Fortunately for us, we have copies of all of these $FILE_NAME attributes in the file’s MFT record.\nThis means a file can have multiple paths. To be exact, a file can have multiple hard links, and each one of them has a path. Each hard link has its own $FILE_NAME attribute, containing its own file name and parent folder. To build all of the paths for a file, we’ll loop over every $FILE_NAME attribute in its MFT record, and use them to build the path of each hard link separately.\nFolders are easier to handle, because NTFS does not allow multiple hard links for them - it would allow you to create loops in the directory tree, and nobody wants that. This means a folder has only a single path. A hard link has a single parent folder - so it also has a single path. This means we’ll build the path of each hard link very similarly to how we did it previously.\nShort Names Short file names (SFNs) are a special type of hard links. If enabled, they’re created automatically for files their names are too long to be handled by some old applications. They provide these old applications with an auto-generated, shorter file name they can handle. A short name is created in the same directory with the original hard link, and we can build the path for it the same way we do for a regular hard link.\nWe can tell whether a $FILE_NAME attribute contains a short name by checking its Filename namespace flag. A DOS namespace means it’s a short name, and a WIN32 or a POSIX namespace means it’s a regular, long name. WIN32 \u0026 DOS is a special value indicating there is no short name for the file, because its name is already a valid short name.\nFolders cannot have regular hard links, but they can have short names. This is a problem - if folders can have 2 different names, it means a hard link can have a huge number of different paths. Suppose a hard link is n folders deep in the directory tree, and each folder has 2 names at most - long and short, excluding the root directory, a hard link has at most 2ⁿ⁻¹ different paths!\n. \\ ??? \\ ??? \\ ??? \\ .... \\ File.txt x2 x2 x2 .... To keep things reasonable, we’ll only use the long name of each folder to build the path of a hard link. By doing so, we’re in fact choosing a single path for it, out of the many it may have. We can get away with it, because we build the paths for the folders in the exact same way. Each folder’s short name is also a hard link, and we’ll build a path for it when we get to that folder’s MFT record. We’re not loosing any short names.\nLong names with the same prefix will have similar short names generated for them. It’s important to output the MFT index of each path, so we can tell which short name belongs to which long name:\nMFT Index Path 59:\t.\\Program Files 1293:\t.\\ProgramData 59:\t.\\PROGRA~1 1293:\t.\\PROGRA~2 PROGRA~1 --\u003e Program Files PROGRA~2 --\u003e ProgramData This is the upgraded code. It now handles hard links, and outputs both long and short names:\nfor current_record in mft.get_records(): build_path(mft, current_record) def build_path(mft, current_record): mft_index = current_record.get_mft_index() for filename_attribute in current_record.get_filename_attributes(): print(mft_index + \": \" + build_path_helper(mft, filename_attribute)) def build_path_helper(mft, filename_attribute): path = \"\" while True path = \"\\\\\" + filename_attribute.get_field(\"Filename\") + path parent_record = mft.get_record_at(filename_attribute.get_field(\"Parent index\")) if is_root_directory(parent_record): break parent_sequence = parent_record.get_sequence_number() if not parent_record.is_used(): parent_sequence -= 1 if parent_sequence != filename_attribute.get_field(\"Parent sequence\"): path = \"\\\\$OrphanFiles\" + path break filename_attribute = next(get_lfn_filename_attributes(parent_record)) return \".\" + path # Get only filename attributes with a Long File Name (LFN) def get_lfn_filename_attributes(file_record): for filename_attribute in file_record.get_filename_attributes(): if filename_attribute.get_field(\"Name space\") != \"DOS\": yield filename_attribute If you don’t care about the short names, you don’t have to build paths for them. You can simply ignore them altogether. That’s perfectly fine, but I believe it’s better to output both long and short names - and group them into a single event, later in the analysis phase. To ignore short names, all we need is a small modification to the build_path function:\ndef build_path(mft, current_record): for filename_attribute in get_lfn_filename_attributes(current_record): print build_path_helper(mft, filename_attribute) Pitfall 3: Extension Records, Missing Attributes and Orphaned Attributes Extension Records If a file becomes extremely large and fragmented, or has many hard links, a single file record may not be big enough to contain all of its attributes. In such case, the file will occupy additional file records. The file’s main record is called the Base Record, and the additional ones are called Extension Records. When some of a file’s attributes are stored in extension records, its base record contains a special attribute, called $ATTRIBUTE_LIST, which stores the information needed to find them.\nSome MFT parsers use the $ATTRIBUTE_LIST attribute in the base record to find its extension records. This is a major mistake, because $ATTRIBUTE_LIST attributes can be non-resident (stored outside the MFT). Instead, we’ll take the opposite approach - find the extension records, and trace them back to their base record.\nConveniently, the file-record header contains a Base index and Base sequence fields, to store a file reference to the base record. In base records, these fields are zeroed out. This means we can also use them to differentiate base records from extension records, without having to check for a $ATTRIBUTE_LIST attribute.\nBy looping over the MFT, we can create a mapping of base records to extension records:\n# a dictionay to map base records to their extension records # mappings are of the form: (n, m) -\u003e [k1, k2, ...], where: # (n, m) is a file reference of a base record # ki is the MFT index of an extension record extension_records = {} for current_record in mft.get_records(): if not is_base_record(current_record): base_index = current_record.get_base_record_index() base_sequence = current_record.get_base_record_sequence() (extension_records .setdefault((base_index, base_sequence), []) .append(current_record.get_mft_index())) def is_base_record(current_record): return (current_record.get_base_record_index() == 0 and current_record.get_base_record_sequeunce() == 0) After we create this dictionary, we have to loop over the MFT one more time. This time, looking for base records. For each base record, we will build a path for all the $FILE_NAME attributes both in it, and in its extension records - if it has any.\nMissing Attributes As always, deleted files create problems. When a file is deleted, its base record and all of its extension records are marked as free. The problem is - all of those free records are not going to be reused all at the same time. If some, but not all of the file’s records are reused - we loose some, but not all of the file’s attributes. This has major consequences on MFT parsing in general, and on path reconstruction in particular.\nWe may find a file without any $FILE_NAME attributes. For such a file, path reconstruction is impossible. The best you can do is give it a unique identifier. You may be tempted to place it in the $OrphanFiles folder, but that wouldn’t be right - it’s not necessarily orphan. Sure, it’s deleted, but its parent folder might not be.\nIf you find a folder without any $FILE_NAME attributes, you may also find deleted files that were once inside it. Those files can be safely placed in the $OrphanFiles folder, because the folder is deleted, and we won’t output a path for it.\nOrphaned Attributes To resolve the parent folder for a file, we validate the parent reference in its $FILE_NAME attribute. If it’s not valid, it means the file is orphan, right? Well, yes - but we can do better than that. Before declaring the file is orphan, we should check whether its parent has any extension records left. If there’s a $FILE_NAME attribute in one of them, we can use it to resolve the file’s path.\nThis is the final version of our code. It handles everything we talked about so far: orphan files, hard links and extension records:\n# a dictionay to map base records to their extension records # mappings are of the form: (n, m) -\u003e [k1, k2, ...], where: # (n, m) is a file reference of a base record # ki is the MFT index of an extension record extension_records = {} # first pass over the MFT for current_record in mft.get_records(): if not is_base_record(current_record): base_index = current_record.get_base_record_index() base_sequence = current_record.get_base_record_sequence() (extension_records .setdefault((base_index, base_sequence), []) .append(current_record.get_mft_index())) # second pass over the MFT for current_record in mft.get_records(): if is_base_record(current_record): build_path(mft, current_record) def is_base_record(current_record): return (current_record.get_base_record_index() == 0 and current_record.get_base_record_sequeunce() == 0) def build_path(mft, current_record): base_filename_attributes = current_record.get_filename_attributes() extension_filename_attributes = get_extension_filename_attributes( current_record.get_mft_index(), current_record.get_sequence_number() ) mft_index = current_record.get_mft_index() for filename_attribute in base_filename_attributes + extension_filename_attributes: print(mft_index + \": \" + build_path_helper(mft, filename_attribute)) def build_path_helper(mft, filename_attribute): path = \"\" while True path = \"\\\\\" + filename_attribute.get_field(\"Filename\") + path parent_record = mft.get_record_at(filename_attribute.get_field(\"Parent index\")) if is_root_directory(parent_record): break parent_sequence = parent_record.get_sequence_number() if not parent_record.is_used(): parent_sequence -= 1 parent_filename_attributes = [] # if parent record still belongs to my parent, get its filename attributes if parent_sequence == filename_attribute.get_field(\"Parent sequence\"): parent_filename_attributes = parent_record.get_filename_attributes() # get the filename attributes from any extension records of my parent parent_filename_attributes += get_extension_filename_attributes( filename_attribute.get_field(\"Parent index\"), filename_attribute.get_field(\"Parent sequence\") ) if not parent_filename_attributes: # could not find a $FILE_NAME attribute of my parent path = \"\\\\$OrphanFiles\" + path break # prioritize LFNs when choosing a name for the parent filename_attribute = max(parent_filename_attributes, key=get_priority) return \".\" + path def get_extension_filename_attributes(base_index, base_sequence): extension_records = map( mft.get_record_at, extension_records[(base_index, base_sequence)] ) filename_attributes = [] for record in extension_records: filename_attributes += record.get_filename_attributes() return filename_attributes def get_priority(filename_attribute): if filename_attribute.get_field(\"Name space\") == \"DOS\": return 0 else: return 1 In the previous version, we built paths using the long file name (LFN) of each folder, because the long names are more meaningful than the auto-generated short names. Now we know that the $FILE_NAME attribute containing the short name may be the only $FILE_NAME attribute left after some of a folder’s records were reused.\nIn this new version, we prioritize the LFN $FILE_NAME attributes, but we will use the SFN $FILE_NAME attribute if it’s the only one left.\nClosing Thoughts This post was my attempt to create the resource I wish I had when I wrote my MFT parser. MFT parsing is such a fundamental technique in forensics; yet, the resources to learn it are lacking. People have been writing MFT parsers for years, each one on their own, rediscovering the same edge cases and learning the same lessons again and again.\nIt really shouldn’t be like that. I think we DFIR programmers have a lot to learn in sharing our knowledge with one another, so we can push the field forward, together.\n",
  "wordCount" : "3401",
  "inLanguage": "en",
  "datePublished": "2022-07-07T00:00:00Z",
  "dateModified": "2022-07-07T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Harel Segev"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://harelsegev.github.io/posts/resolving-file-paths-using-the-mft/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "RAT In Mi Kitchen",
    "logo": {
      "@type": "ImageObject",
      "url": "https://harelsegev.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://harelsegev.github.io/" accesskey="h" title="RAT In Mi Kitchen (Alt + H)">RAT In Mi Kitchen</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://harelsegev.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://harelsegev.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://harelsegev.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://harelsegev.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://harelsegev.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://harelsegev.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://harelsegev.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Resolving File Paths Using the MFT
    </h1>
    <div class="post-meta"><span title='2022-07-07 00:00:00 +0000 UTC'>July 7, 2022</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;3401 words&nbsp;·&nbsp;Harel Segev

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#before-we-start">Before we Start</a></li>
    <li><a href="#a-naive--approach">A Naive  Approach</a></li>
    <li><a href="#pitfall-1-orphan-files--the-sequence-number">Pitfall 1: Orphan Files &amp; the Sequence Number</a>
      <ul>
        <li><a href="#orphan-files">Orphan Files</a></li>
        <li><a href="#the-sequence-number">The Sequence Number</a></li>
      </ul>
    </li>
    <li><a href="#pitfall-2-hard-links-and-short-names">Pitfall 2: Hard Links and Short Names</a>
      <ul>
        <li><a href="#hard-links">Hard Links</a></li>
        <li><a href="#short-names">Short Names</a></li>
      </ul>
    </li>
    <li><a href="#pitfall-3-extension-records-missing-attributes-and-orphaned-attributes">Pitfall 3: Extension Records, Missing Attributes and Orphaned Attributes</a>
      <ul>
        <li><a href="#extension-records">Extension Records</a></li>
        <li><a href="#missing-attributes">Missing Attributes</a></li>
        <li><a href="#orphaned-attributes">Orphaned Attributes</a></li>
      </ul>
    </li>
    <li><a href="#closing-thoughts">Closing Thoughts</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>In NTFS, the MFT (Master File Table) is a structure that contains a lot of the file-system metadata, and also the contents of small files. It is stored in a special file, called <code>$MFT</code>. In incident response, we often collect and parse this file to determine the file system contents and how it changed over time, without having to acquire a full disk image.</p>
<p>There are many bad MFT parsers out there. This is no coincidence - an MFT parser is an extremely easy thing to mess up. Most MFT parsers don&rsquo;t bother handling the uncommon edge cases - and they work fine, most of the times. The fact is, some of those uncommon edge cases are actually more common than you would think. Handling them correctly is what sets the good MFT parsers apart from the bad ones.</p>
<p>The MFT is an array of  file records - each one describes a file on the system. File records do not to store directory hierarchy, though. There&rsquo;s another structure for that - directory indexes. The directory index a file is listed in determines its location in the directory tree. The directory index is the one storing the name of the file, inside a structure called a <code>$FILE_NAME</code> attribute.</p>
<p>Reconstructing full file paths using only the MFT is not trivial. Whether it is a reliable method at all is debatable. It is only possible because of an NTFS quirk - There&rsquo;s a backup of every file&rsquo;s <code>$FILE_NAME</code> attribute inside its MFT record. Nonetheless, this method is simple, fast, and is often good enough. In this post, I&rsquo;ll help you avoid its common implementation pitfalls.</p>
<h2 id="before-we-start">Before we Start<a hidden class="anchor" aria-hidden="true" href="#before-we-start">#</a></h2>
<p>Given a <code>$MFT</code> file, we first have to determine the size of an individual file record. It&rsquo;s usually 1024 bytes, but it doesn&rsquo;t have to be. This value is stored in the file system boot sector - which we don&rsquo;t have. Instead, we can find any two consecutive file records, and calculate the difference between their offsets. This should give us the size of a file record.</p>
<p>Another thing to consider, is that file records, like other important file system structures, use <a href="https://flatcap.github.io/linux-ntfs/ntfs/concepts/fixup.html">fixup values</a> to detect disk errors. If you ignore fixup values, your parser will output incorrect data, and the worst part is - you are probably not going to notice. Take my word for it, and start writing the code to deal with fixup values early on.</p>
<h2 id="a-naive--approach">A Naive  Approach<a hidden class="anchor" aria-hidden="true" href="#a-naive--approach">#</a></h2>
<p>This is the structure of a <code>$FILE_NAME</code> attribute:</p>
<table>
<thead>
<tr>
<th>Offset</th>
<th>Size</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x00</td>
<td>6</td>
<td style="text-align:left">Parent index</td>
</tr>
<tr>
<td>0x06</td>
<td>2</td>
<td style="text-align:left">Parent sequence</td>
</tr>
<tr>
<td>0x08</td>
<td>8</td>
<td style="text-align:left">Creation time</td>
</tr>
<tr>
<td>0x10</td>
<td>8</td>
<td style="text-align:left">Modification time</td>
</tr>
<tr>
<td>0x18</td>
<td>8</td>
<td style="text-align:left">MFT record change time</td>
</tr>
<tr>
<td>0x20</td>
<td>8</td>
<td style="text-align:left">Access time</td>
</tr>
<tr>
<td>0x28</td>
<td>8</td>
<td style="text-align:left">Allocated size</td>
</tr>
<tr>
<td>0x30</td>
<td>8</td>
<td style="text-align:left">Real size</td>
</tr>
<tr>
<td>0x38</td>
<td>4</td>
<td style="text-align:left">Flags</td>
</tr>
<tr>
<td>0x3C</td>
<td>4</td>
<td style="text-align:left">Used by EAs and Reparse</td>
</tr>
<tr>
<td>0x40</td>
<td>1</td>
<td style="text-align:left">Filename length in bytes / 2 (L)</td>
</tr>
<tr>
<td>0x41</td>
<td>1</td>
<td style="text-align:left">Filename namespace</td>
</tr>
<tr>
<td>0x42</td>
<td>2L</td>
<td style="text-align:left">Filename in Unicode (not null terminated)</td>
</tr>
</tbody>
</table>
<p>As mentioned earlier, each file has a <code>$FILE_NAME</code> attribute inside its MFT record. For now, we&rsquo;re only interested in these 2 fields:</p>
<ul>
<li>
<p><code>Filename</code><br>
The name of the file described by the record.</p>
</li>
<li>
<p><code>Parent index</code><br>
An index to the MFT record of the file&rsquo;s parent folder.</p>
</li>
</ul>
<p>Using these fields, we can build the full path of a file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>                +--------------+
</span></span><span style="display:flex;"><span>    +----------&gt;| .            |    4. .\Documents\PDF\document.pdf
</span></span><span style="display:flex;"><span>    |           +--------------+        
</span></span><span style="display:flex;"><span>    |  +-------&gt;| Documents    |    3. Documents\PDF\document.pdf
</span></span><span style="display:flex;"><span>    +--|--------+--------------+
</span></span><span style="display:flex;"><span>       |        |              |
</span></span><span style="display:flex;"><span>       |        +--------------+
</span></span><span style="display:flex;"><span>       |  +----&gt;| PDF          |    2. PDF\document.pdf
</span></span><span style="display:flex;"><span>       +--|-----+--------------+
</span></span><span style="display:flex;"><span>          |     |              |
</span></span><span style="display:flex;"><span>          |     +--------------+
</span></span><span style="display:flex;"><span>          |     |              |
</span></span><span style="display:flex;"><span>          |     +--------------+
</span></span><span style="display:flex;"><span>          |     | document.pdf |    1. document.pdf
</span></span><span style="display:flex;"><span>          +-----+--------------+
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In NTFS, &#34;.&#34; is the file name of the root directory.
</span></span></code></pre></div><p>By looping over the MFT records, we can do this for every file on the system. Here&rsquo;s a Python-style pseudo code of the algorithm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    print(build_path(mft, current_record))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path</span>(mft, current_record):
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> is_root_directory(current_record):
</span></span><span style="display:flex;"><span>        filename_attribute <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_attribute(<span style="color:#e6db74">&#34;$FILE_NAME&#34;</span>)
</span></span><span style="display:flex;"><span>        path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Filename&#34;</span>) <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>        current_record <span style="color:#f92672">=</span> mft<span style="color:#f92672">.</span>get_record_at(filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent index&#34;</span>))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> path
</span></span></code></pre></div><p>Of course, we could have used caching to improve the efficiency - but for the sake of simplicity, all of the code in this post will be pretty inefficient. In the next sections, we&rsquo;ll see how deleted files, hard links and extension records break everything, and we&rsquo;ll change our code to deal with them.</p>
<h2 id="pitfall-1-orphan-files--the-sequence-number">Pitfall 1: Orphan Files &amp; the Sequence Number<a hidden class="anchor" aria-hidden="true" href="#pitfall-1-orphan-files--the-sequence-number">#</a></h2>
<p>The first edge case we&rsquo;ll discuss involves deleted files. When a file is deleted, its MFT record is marked as free. Then, it can be reused if a new file is created - why add a new record to the MFT when there&rsquo;s a free, existing one? If there are multiple free records, and a new file is created - it may occupy either one of them.</p>
<p>We can tell whether a record is in use by looking at the <code>Flags</code> field in the record header, and more specifically - at its least significant bit, which is the flag representing the state of the record. When a record is allocated to a file, it is set. When that file is deleted, it is turned off.</p>
<h3 id="orphan-files">Orphan Files<a hidden class="anchor" aria-hidden="true" href="#orphan-files">#</a></h3>
<p>As long as the record of a deleted file is not reused - it remains intact, which means we can resolve the file&rsquo;s path just like any other file. Problems may arise if the file&rsquo;s parent folder is deleted as well. Let&rsquo;s see what happens when the parent folder&rsquo;s record is reused, while the child&rsquo;s record remains free:</p>
<ol>
<li>
<p>Folder1 is created. It occupies the MFT record at index 41</p>
<table>
<thead>
<tr>
<th>Record state</th>
<th>Record index</th>
<th>Reconstructed file path</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>In use</code></td>
<td>41</td>
<td>.\Folder1</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>File1.txt is created inside Folder1. It occupies the MFT record at index 42</p>
<table>
<thead>
<tr>
<th>Record state</th>
<th>Record index</th>
<th>Reconstructed file path</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>In use</code></td>
<td>41</td>
<td>.\Folder1</td>
</tr>
<tr>
<td><code>In use</code></td>
<td>42</td>
<td>.\Folder1\File1.txt</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Folder1 is deleted. File1.txt is in Folder1, so it is also deleted</p>
<table>
<thead>
<tr>
<th>Record state</th>
<th>Record index</th>
<th>Reconstructed file path</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Free</code></td>
<td>41</td>
<td>.\Folder1</td>
</tr>
<tr>
<td><code>Free</code></td>
<td>42</td>
<td>.\Folder1\File1.txt</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Folder2 is created. It occupies the MFT record at index 41</p>
<table>
<thead>
<tr>
<th>Record state</th>
<th>Record index</th>
<th>Reconstructed file path</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>In use</code></td>
<td>41</td>
<td>.\Folder2.txt</td>
</tr>
<tr>
<td><code>Free</code></td>
<td>42</td>
<td>.\Folder2\File1.txt</td>
</tr>
</tbody>
</table>
</li>
</ol>
<p>File1.txt was never in Folder2!</p>
<p>Deleted files their parent folder&rsquo;s record was reused are called <em>Orphan Files</em>. They were once created in some folder, but it is now gone. their original path cannot be resolved. A folder can be orphan too, which will make it the root of an orphan sub-tree. The hierarchy of the files inside an orphan sub-tree can be reconstructed, but it&rsquo;s detached from the main directory tree. the original path of the root of the sub-tree, which is an orphan folder, cannot be resolved.</p>
<h3 id="the-sequence-number">The Sequence Number<a hidden class="anchor" aria-hidden="true" href="#the-sequence-number">#</a></h3>
<p>On its own, an MFT index is not enough to reference a file. It references a record, which can be reused to describe many files over time. We don&rsquo;t want to reference records, we want to reference the files they describe. To reference a file, not only do we need to know its MFT index, but also whether the record in that index still belongs to it, or has been reused since.</p>
<p>This is where the sequence number comes in. It is stored in the record header, and is used together with the MFT index to reference files. That&rsquo;s why together, they are called a <em>File Reference</em>. Every time a record is <strong>freed</strong>, its sequence number is increased by 1. Then, any file references with the old sequence number are considered invalid.</p>
<p>Here&rsquo;s a pseudo-code of a reference validation function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_valid_file_reference</span>(mft, mft_index, sequence_number):
</span></span><span style="display:flex;"><span>	file_record <span style="color:#f92672">=</span> mft<span style="color:#f92672">.</span>get_record_at(mft_index)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> file_record<span style="color:#f92672">.</span>is_used():
</span></span><span style="display:flex;"><span>	    <span style="color:#66d9ef">return</span> file_record<span style="color:#f92672">.</span>get_sequence_number() <span style="color:#f92672">==</span> sequence_number
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># the sequence number was increased when the record was freed, </span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># so we should decrease it to get the actual sequence number of the file</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> file_record<span style="color:#f92672">.</span>get_sequence_number() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">==</span> sequence_number
</span></span></code></pre></div><p>Look again at the structure of the <code>$FILE_NAME</code> attribute. Not only do we have the MFT index of the parent folder, but also its sequence number. In other words - we have a file reference to the parent folder. This is exactly what we need to identify orphan files - all we need to do is validate this reference. If it&rsquo;s not valid, it means the parent folder was deleted, and its record was reused.</p>
<p>Now that we can identify orphan files, we have to decide how our code should deal with them. We could output the filenames and paths separately, and just not output a path for them. Or maybe we can place them all in some special folder, but which one? There&rsquo;s no folder it would be right to place them in. The solution we&rsquo;ll go with is quite simple: we&rsquo;ll just create a new folder for them.</p>
<p>Of course, it won&rsquo;t be an actual file system folder - we cannot create these. Nevertheless, we are the ones building the directory tree, so we can just &ldquo;make up&rdquo; a folder. It would be a &ldquo;virtual folder&rdquo;, if you will. We&rsquo;ll call it &ldquo;$OrphanFiles&rdquo; and place it in the root directory. Now we have a foster parent for all the orphan files!</p>
<p>Here&rsquo;s our upgraded code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    print(build_path(mft, current_record))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path</span>(mft, current_record):
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">not</span> is_root_directory(current_record):
</span></span><span style="display:flex;"><span>        filename_attribute <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_attribute(<span style="color:#e6db74">&#34;$FILE_NAME&#34;</span>)
</span></span><span style="display:flex;"><span>        path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Filename&#34;</span>) <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>        current_record <span style="color:#f92672">=</span> mft<span style="color:#f92672">.</span>get_record_at(filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent index&#34;</span>))
</span></span><span style="display:flex;"><span>		
</span></span><span style="display:flex;"><span>        sequence_number <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_sequence_number()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> current_record<span style="color:#f92672">.</span>is_used():
</span></span><span style="display:flex;"><span>            sequence number <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> sequence_number <span style="color:#f92672">!=</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent sequence&#34;</span>):
</span></span><span style="display:flex;"><span>            path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">$OrphanFiles&#34;</span> <span style="color:#f92672">+</span> path 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> path
</span></span></code></pre></div><h2 id="pitfall-2-hard-links-and-short-names">Pitfall 2: Hard Links and Short Names<a hidden class="anchor" aria-hidden="true" href="#pitfall-2-hard-links-and-short-names">#</a></h2>
<h3 id="hard-links">Hard Links<a hidden class="anchor" aria-hidden="true" href="#hard-links">#</a></h3>
<p>Hard links are an often overlooked feature of NTFS. They are similar in functionality to the hard links in other file systems - a file can be located in multiple folders at the same time, and can have a different name in each one. Each directory index a file is located in stores a <code>$FILE_NAME</code> attribute for it. Fortunately for us, we have copies of all of these <code>$FILE_NAME</code> attributes in the file&rsquo;s MFT record.</p>
<p>This means a file can have multiple paths. To be exact, a file can have multiple hard links, and each one of <em>them</em> has a path. Each hard link has its own <code>$FILE_NAME</code>  attribute, containing its own file name and parent folder. To build all of the paths for a file, we&rsquo;ll loop over every <code>$FILE_NAME</code> attribute in its MFT record, and use them to build the path of each hard link separately.</p>
<p>Folders are easier to handle, because NTFS does not allow multiple hard links for them - it would allow you to create loops in the directory tree, and nobody wants that. This means a folder has only a single path. A hard link has a single parent folder - so it also has a single path. This means we&rsquo;ll build the path of each hard link very similarly to how we did it previously.</p>
<h3 id="short-names">Short Names<a hidden class="anchor" aria-hidden="true" href="#short-names">#</a></h3>
<p>Short file names (SFNs) are a special type of hard links. If enabled, they&rsquo;re created automatically for files their names are too long to be handled by some old applications. They provide these old applications with an auto-generated, shorter file name they can handle. A short name is created in the same directory with the original hard link, and we can build the path for it the same way we do for a regular hard link.</p>
<p>We can tell whether a <code>$FILE_NAME</code> attribute contains a short name by checking its <em>Filename namespace</em> flag. A <code>DOS</code> namespace means it&rsquo;s a short name, and a <code>WIN32</code> or a <code>POSIX</code> namespace means it&rsquo;s a regular, long name. <code>WIN32 &amp; DOS</code> is a special value indicating there is no short name for the file, because its name is already a valid short name.</p>
<p>Folders cannot have regular hard links, but they can have short names. This is a problem - if folders can have 2 different names, it means a hard link can have a huge number of different paths. Suppose a hard link is <code>n</code> folders deep in the directory tree, and each folder has 2 names at most - long and short, excluding the root directory, a hard link has at most <code>2ⁿ⁻¹</code> different paths!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>. \ ??? \ ??? \ ??? \ .... \ File.txt
</span></span><span style="display:flex;"><span>     x2    x2    x2    ....
</span></span></code></pre></div><p>To keep things reasonable, we&rsquo;ll only use the long name of each folder to build the path of a hard link. By doing so, we&rsquo;re in fact choosing a single path for it, out of the many it may have. We can get away with it, because we build the paths for the folders in the exact same way. Each folder&rsquo;s short name is also a hard link, and we&rsquo;ll build a path for it when we get to that folder&rsquo;s MFT record. We&rsquo;re not loosing any short names.</p>
<p>Long names with the same prefix will have similar short names generated for them. It&rsquo;s important to output the MFT index of each path, so we can tell which short name belongs to which long name:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-markdown" data-lang="markdown"><span style="display:flex;"><span>MFT Index    Path
</span></span><span style="display:flex;"><span>59:			.\Program Files
</span></span><span style="display:flex;"><span>1293:		.\ProgramData
</span></span><span style="display:flex;"><span>59:			.\PROGRA~1
</span></span><span style="display:flex;"><span>1293:		.\PROGRA~2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PROGRA~1 --&gt; Program Files
</span></span><span style="display:flex;"><span>PROGRA~2 --&gt; ProgramData
</span></span></code></pre></div><p>This is the upgraded code. It now handles hard links, and outputs both long and short names:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    build_path(mft, current_record)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path</span>(mft, current_record):
</span></span><span style="display:flex;"><span>	mft_index <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_mft_index()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> filename_attribute <span style="color:#f92672">in</span> current_record<span style="color:#f92672">.</span>get_filename_attributes():
</span></span><span style="display:flex;"><span>        print(mft_index <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">+</span> build_path_helper(mft, filename_attribute))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path_helper</span>(mft, filename_attribute):
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Filename&#34;</span>) <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>        parent_record <span style="color:#f92672">=</span> mft<span style="color:#f92672">.</span>get_record_at(filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent index&#34;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> is_root_directory(parent_record):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        parent_sequence <span style="color:#f92672">=</span> parent_record<span style="color:#f92672">.</span>get_sequence_number()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> parent_record<span style="color:#f92672">.</span>is_used():
</span></span><span style="display:flex;"><span>            parent_sequence <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> parent_sequence <span style="color:#f92672">!=</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent sequence&#34;</span>):
</span></span><span style="display:flex;"><span>            path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">$OrphanFiles&#34;</span> <span style="color:#f92672">+</span> path 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        filename_attribute <span style="color:#f92672">=</span> next(get_lfn_filename_attributes(parent_record))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Get only filename attributes with a Long File Name (LFN)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_lfn_filename_attributes</span>(file_record):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> filename_attribute <span style="color:#f92672">in</span> file_record<span style="color:#f92672">.</span>get_filename_attributes():
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Name space&#34;</span>) <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;DOS&#34;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">yield</span> filename_attribute
</span></span></code></pre></div><p>If you don&rsquo;t care about the short names, you don&rsquo;t have to build paths for them. You can simply ignore them altogether. That&rsquo;s perfectly fine, but I believe it&rsquo;s better to output both long and short names - and group them into a single event, later in the analysis phase. To ignore short names, all we need is a small modification to the <code>build_path</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path</span>(mft, current_record):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> filename_attribute <span style="color:#f92672">in</span> get_lfn_filename_attributes(current_record):
</span></span><span style="display:flex;"><span>        print build_path_helper(mft, filename_attribute)
</span></span></code></pre></div><h2 id="pitfall-3-extension-records-missing-attributes-and-orphaned-attributes">Pitfall 3: Extension Records, Missing Attributes and Orphaned Attributes<a hidden class="anchor" aria-hidden="true" href="#pitfall-3-extension-records-missing-attributes-and-orphaned-attributes">#</a></h2>
<h3 id="extension-records">Extension Records<a hidden class="anchor" aria-hidden="true" href="#extension-records">#</a></h3>
<p>If a file becomes extremely large and fragmented, or has many hard links, a single file record may not be big enough to contain all of its attributes. In such case, the file will occupy additional file records. The file&rsquo;s main record is called the <em>Base Record</em>, and the additional ones are called <em>Extension Records</em>. When some of a file&rsquo;s attributes are stored in extension records, its base record contains a special attribute, called <code>$ATTRIBUTE_LIST</code>, which stores the information needed to find them.</p>
<p>Some MFT parsers use the <code>$ATTRIBUTE_LIST</code> attribute in the base record to find its extension records. This is a major mistake, because <code>$ATTRIBUTE_LIST</code> attributes can be non-resident (stored outside the MFT). Instead, we&rsquo;ll take the opposite approach - find the extension records, and trace them back to their base record.</p>
<p>Conveniently, the file-record header contains a <code>Base index</code> and <code>Base sequence</code> fields, to store a file reference to the base record. In base records, these fields are zeroed out. This means we can also use them to differentiate base records from extension records, without having to check for a <code>$ATTRIBUTE_LIST</code> attribute.</p>
<p>By looping over the MFT, we can create a mapping of base records to extension records:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#75715e"># a dictionay to map base records to their extension records</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mappings are of the form: (n, m) -&gt; [k1, k2, ...], where:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># (n, m) is a file reference of a base record</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ki is the MFT index of an extension record</span>
</span></span><span style="display:flex;"><span>extension_records <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_base_record(current_record):
</span></span><span style="display:flex;"><span>        base_index <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_base_record_index()
</span></span><span style="display:flex;"><span>        base_sequence <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_base_record_sequence()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        (extension_records
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>setdefault((base_index, base_sequence), [])
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>append(current_record<span style="color:#f92672">.</span>get_mft_index()))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_base_record</span>(current_record):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (current_record<span style="color:#f92672">.</span>get_base_record_index() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>            current_record<span style="color:#f92672">.</span>get_base_record_sequeunce() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span></code></pre></div><p>After we create this dictionary, we have to loop over the MFT one more time. This time, looking for base records. For each base record, we will build a path for all the <code>$FILE_NAME</code> attributes both in it, and in its extension records - if it has any.</p>
<h3 id="missing-attributes">Missing Attributes<a hidden class="anchor" aria-hidden="true" href="#missing-attributes">#</a></h3>
<p>As always, deleted files create problems. When a file is deleted, its base record and all of its extension records are marked as free. The problem is - all of those free records are not going to be reused all at the same time. If some, but not all of the file&rsquo;s records are reused - we loose some, but not all of the file&rsquo;s attributes. This has major consequences on MFT parsing in general, and on path reconstruction in particular.</p>
<p>We may find a file without any <code>$FILE_NAME</code> attributes. For such a file, path reconstruction is impossible. The best you can do is give it a unique identifier. You may be tempted to place it in the $OrphanFiles folder, but that wouldn&rsquo;t be right -  it&rsquo;s not necessarily orphan. Sure, it&rsquo;s deleted, but its parent folder might not be.</p>
<p>If you find a <strong>folder</strong> without any <code>$FILE_NAME</code> attributes, you may also find deleted files that were once inside it. Those files can be safely placed in the $OrphanFiles folder, because the folder is deleted, and we won&rsquo;t output a path for it.</p>
<h3 id="orphaned-attributes">Orphaned Attributes<a hidden class="anchor" aria-hidden="true" href="#orphaned-attributes">#</a></h3>
<p>To resolve the parent folder for a file, we validate the parent reference in its <code>$FILE_NAME</code> attribute. If it&rsquo;s not valid, it means the file is orphan, right? Well, yes - but we can do better than that. Before declaring the file is orphan, we should check whether its parent has any extension records left. If there&rsquo;s a <code>$FILE_NAME</code> attribute in one of them, we can use it to resolve the file&rsquo;s path.</p>
<p>This is the final version of our code. It handles everything we talked about so far: orphan files, hard links and extension records:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python3" data-lang="python3"><span style="display:flex;"><span><span style="color:#75715e"># a dictionay to map base records to their extension records</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># mappings are of the form: (n, m) -&gt; [k1, k2, ...], where:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># (n, m) is a file reference of a base record</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ki is the MFT index of an extension record</span>
</span></span><span style="display:flex;"><span>extension_records <span style="color:#f92672">=</span> {}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># first pass over the MFT</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> is_base_record(current_record):
</span></span><span style="display:flex;"><span>        base_index <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_base_record_index()
</span></span><span style="display:flex;"><span>        base_sequence <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_base_record_sequence()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        (extension_records
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>setdefault((base_index, base_sequence), [])
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">.</span>append(current_record<span style="color:#f92672">.</span>get_mft_index()))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># second pass over the MFT</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> current_record <span style="color:#f92672">in</span> mft<span style="color:#f92672">.</span>get_records():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> is_base_record(current_record):
</span></span><span style="display:flex;"><span>        build_path(mft, current_record)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">is_base_record</span>(current_record):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (current_record<span style="color:#f92672">.</span>get_base_record_index() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">and</span>
</span></span><span style="display:flex;"><span>            current_record<span style="color:#f92672">.</span>get_base_record_sequeunce() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path</span>(mft, current_record):    
</span></span><span style="display:flex;"><span>    base_filename_attributes <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_filename_attributes()
</span></span><span style="display:flex;"><span>    extension_filename_attributes <span style="color:#f92672">=</span> get_extension_filename_attributes(
</span></span><span style="display:flex;"><span>        current_record<span style="color:#f92672">.</span>get_mft_index(),
</span></span><span style="display:flex;"><span>        current_record<span style="color:#f92672">.</span>get_sequence_number()
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    mft_index <span style="color:#f92672">=</span> current_record<span style="color:#f92672">.</span>get_mft_index()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> filename_attribute <span style="color:#f92672">in</span> base_filename_attributes <span style="color:#f92672">+</span> extension_filename_attributes:
</span></span><span style="display:flex;"><span>    	print(mft_index <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">+</span> build_path_helper(mft, filename_attribute))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">build_path_helper</span>(mft, filename_attribute):
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>        path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">+</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Filename&#34;</span>) <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>        parent_record <span style="color:#f92672">=</span> mft<span style="color:#f92672">.</span>get_record_at(filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent index&#34;</span>))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> is_root_directory(parent_record):
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        parent_sequence <span style="color:#f92672">=</span> parent_record<span style="color:#f92672">.</span>get_sequence_number()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> parent_record<span style="color:#f92672">.</span>is_used():
</span></span><span style="display:flex;"><span>            parent_sequence <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        parent_filename_attributes <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># if parent record still belongs to my parent, get its filename attributes</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> parent_sequence <span style="color:#f92672">==</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent sequence&#34;</span>):
</span></span><span style="display:flex;"><span>            parent_filename_attributes <span style="color:#f92672">=</span> parent_record<span style="color:#f92672">.</span>get_filename_attributes()
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># get the filename attributes from any extension records of my parent</span>
</span></span><span style="display:flex;"><span>        parent_filename_attributes <span style="color:#f92672">+=</span> get_extension_filename_attributes(
</span></span><span style="display:flex;"><span>        	filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent index&#34;</span>),
</span></span><span style="display:flex;"><span>            filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Parent sequence&#34;</span>)
</span></span><span style="display:flex;"><span>        )
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> parent_filename_attributes:
</span></span><span style="display:flex;"><span>	        <span style="color:#75715e"># could not find a $FILE_NAME attribute of my parent</span>
</span></span><span style="display:flex;"><span>            path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">$OrphanFiles&#34;</span> <span style="color:#f92672">+</span> path 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># prioritize LFNs when choosing a name for the parent</span>
</span></span><span style="display:flex;"><span>        filename_attribute <span style="color:#f92672">=</span> max(parent_filename_attributes, key<span style="color:#f92672">=</span>get_priority)        
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">+</span> path
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_extension_filename_attributes</span>(base_index, base_sequence):
</span></span><span style="display:flex;"><span>    extension_records <span style="color:#f92672">=</span>  map(
</span></span><span style="display:flex;"><span>    	mft<span style="color:#f92672">.</span>get_record_at, 
</span></span><span style="display:flex;"><span>    	extension_records[(base_index, base_sequence)]
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    filename_attributes <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> record <span style="color:#f92672">in</span> extension_records:
</span></span><span style="display:flex;"><span>        filename_attributes <span style="color:#f92672">+=</span> record<span style="color:#f92672">.</span>get_filename_attributes()
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> filename_attributes
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_priority</span>(filename_attribute):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> filename_attribute<span style="color:#f92672">.</span>get_field(<span style="color:#e6db74">&#34;Name space&#34;</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;DOS&#34;</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>In the previous version, we built paths using the long file name (LFN) of each folder, because the long names are more meaningful than the auto-generated short names. Now we know that the <code>$FILE_NAME</code> attribute containing the short name may be the only <code>$FILE_NAME</code> attribute left after some of a folder&rsquo;s records were reused.</p>
<p>In this new version, we prioritize the LFN <code>$FILE_NAME</code> attributes, but we will use the SFN <code>$FILE_NAME</code> attribute if it&rsquo;s the only one left.</p>
<h2 id="closing-thoughts">Closing Thoughts<a hidden class="anchor" aria-hidden="true" href="#closing-thoughts">#</a></h2>
<p>This post was my attempt to create the resource I wish I had when I wrote my MFT parser. MFT parsing is such a fundamental technique in forensics; yet, the resources to learn it are lacking. People have been writing MFT parsers for years, each one on their own, rediscovering the same edge cases and learning the same lessons again and again.</p>
<p>It really shouldn&rsquo;t be like that. I think we DFIR programmers have a lot to learn in sharing our knowledge with one another, so we can push the field forward, together.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://harelsegev.github.io/tags/ntfs/">NTFS</a></li>
      <li><a href="https://harelsegev.github.io/tags/mft/">MFT</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://harelsegev.github.io/posts/the-mystery-of-the-heapleakdetection-registry-key/">
    <span class="title">« Prev</span>
    <br>
    <span>The Mystery of the HeapLeakDetection Registry Key</span>
  </a>
  <a class="next" href="https://harelsegev.github.io/posts/home-adventures/home-adventures-a-prefetch-file-in-i30-slack-pyinstaller-prefetch-hash-cracking/">
    <span class="title">Next »</span>
    <br>
    <span>Home Adventures! A Prefetch File in $I30 Slack, PyInstaller &amp; Prefetch Hash Cracking</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Resolving File Paths Using the MFT on twitter"
        href="https://twitter.com/intent/tweet/?text=Resolving%20File%20Paths%20Using%20the%20MFT&amp;url=https%3a%2f%2fharelsegev.github.io%2fposts%2fresolving-file-paths-using-the-mft%2f&amp;hashtags=NTFS%2cMFT">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Resolving File Paths Using the MFT on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fharelsegev.github.io%2fposts%2fresolving-file-paths-using-the-mft%2f&amp;title=Resolving%20File%20Paths%20Using%20the%20MFT&amp;summary=Resolving%20File%20Paths%20Using%20the%20MFT&amp;source=https%3a%2f%2fharelsegev.github.io%2fposts%2fresolving-file-paths-using-the-mft%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Resolving File Paths Using the MFT on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fharelsegev.github.io%2fposts%2fresolving-file-paths-using-the-mft%2f&title=Resolving%20File%20Paths%20Using%20the%20MFT">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Resolving File Paths Using the MFT on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fharelsegev.github.io%2fposts%2fresolving-file-paths-using-the-mft%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Resolving File Paths Using the MFT on whatsapp"
        href="https://api.whatsapp.com/send?text=Resolving%20File%20Paths%20Using%20the%20MFT%20-%20https%3a%2f%2fharelsegev.github.io%2fposts%2fresolving-file-paths-using-the-mft%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Resolving File Paths Using the MFT on telegram"
        href="https://telegram.me/share/url?text=Resolving%20File%20Paths%20Using%20the%20MFT&amp;url=https%3a%2f%2fharelsegev.github.io%2fposts%2fresolving-file-paths-using-the-mft%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer><script src="https://utteranc.es/client.js"
        repo="harelsegev/harelsegev.github.io"
        issue-term="pathname"
        label="blog comment"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://harelsegev.github.io/">RAT In Mi Kitchen</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
