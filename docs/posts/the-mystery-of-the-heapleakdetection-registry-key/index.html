<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>The Mystery of the HeapLeakDetection Registry Key | RAT In Mi Kitchen</title>
<meta name="keywords" content="Registry, HeapLeakDetection">
<meta name="description" content="I was working on a case the other day, when I first came across a rather interesting registry key, HKLM\Software\Microsoft\RADAR\HeapLeakDetection\DiagnosedApplications. It caught my eye, because it has sub-keys for (what appears to be) applications executed on the system. This is what it looks like on my own system:
It has quite a few sub-keys, and each one has a LastDetectionTime QWORD value, containing what appears to be a Windows FILETIME timestamp:">
<meta name="author" content="Harel Segev">
<link rel="canonical" href="https://harelsegev.github.io/posts/the-mystery-of-the-heapleakdetection-registry-key/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.0b739a2e2c5e5656e4bcd5f0b2268d063addaf81d89ec3987d6af8f04decdc97.css" integrity="sha256-C3OaLixeVlbkvNXwsiaNBjrdr4HYnsOYfWr48E3s3Jc=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://harelsegev.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://harelsegev.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://harelsegev.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://harelsegev.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://harelsegev.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="The Mystery of the HeapLeakDetection Registry Key" />
<meta property="og:description" content="I was working on a case the other day, when I first came across a rather interesting registry key, HKLM\Software\Microsoft\RADAR\HeapLeakDetection\DiagnosedApplications. It caught my eye, because it has sub-keys for (what appears to be) applications executed on the system. This is what it looks like on my own system:
It has quite a few sub-keys, and each one has a LastDetectionTime QWORD value, containing what appears to be a Windows FILETIME timestamp:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://harelsegev.github.io/posts/the-mystery-of-the-heapleakdetection-registry-key/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-20T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-07-20T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="The Mystery of the HeapLeakDetection Registry Key"/>
<meta name="twitter:description" content="I was working on a case the other day, when I first came across a rather interesting registry key, HKLM\Software\Microsoft\RADAR\HeapLeakDetection\DiagnosedApplications. It caught my eye, because it has sub-keys for (what appears to be) applications executed on the system. This is what it looks like on my own system:
It has quite a few sub-keys, and each one has a LastDetectionTime QWORD value, containing what appears to be a Windows FILETIME timestamp:"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://harelsegev.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "The Mystery of the HeapLeakDetection Registry Key",
      "item": "https://harelsegev.github.io/posts/the-mystery-of-the-heapleakdetection-registry-key/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "The Mystery of the HeapLeakDetection Registry Key",
  "name": "The Mystery of the HeapLeakDetection Registry Key",
  "description": "I was working on a case the other day, when I first came across a rather interesting registry key, HKLM\\Software\\Microsoft\\RADAR\\HeapLeakDetection\\DiagnosedApplications. It caught my eye, because it has sub-keys for (what appears to be) applications executed on the system. This is what it looks like on my own system:\nIt has quite a few sub-keys, and each one has a LastDetectionTime QWORD value, containing what appears to be a Windows FILETIME timestamp:",
  "keywords": [
    "Registry", "HeapLeakDetection"
  ],
  "articleBody": "I was working on a case the other day, when I first came across a rather interesting registry key, HKLM\\Software\\Microsoft\\RADAR\\HeapLeakDetection\\DiagnosedApplications. It caught my eye, because it has sub-keys for (what appears to be) applications executed on the system. This is what it looks like on my own system:\nIt has quite a few sub-keys, and each one has a LastDetectionTime QWORD value, containing what appears to be a Windows FILETIME timestamp:\nThis key is associated with the Memory Leak Diagnoser component of Windows Resource Exhaustion Detection and Resolution (RADAR). RADAR is a technology embedded in Windows to detect memory leaks in real-time, so that data can be collected and used to correct issues in applications.\nRADAR is surprisingly old; it was introduced in Windows Vista. Nevertheless, I couldn’t find any research into this registry key - so I had to conduct my own. With forensics in mind, I tried to answer these 2 questions:\nUnder what conditions is a sub-key created beneath the DiagnosedApplications key? Under what conditions is the LastDetectionTime value updated? My research was conducted on Windows 10 machines, and therefore may not apply to prior versions of Windows.\nLooking at the Settings Luckily, there’s a Settings key beneath the HeapLeakDetection key:\nSettings are always helpful when you’re trying to figure out how something works. Looking at these values, I already had some hypotheses. I figured whether an application is diagnosed has something to do with the amount of memory it allocated.\nI had a guess that CommitFloor and CommitCeiling are actually in megabytes, and that the amount of committed memory has to lie between them for a process to be registered. That lead me to write a little C program, to test this theory:\n#include #include int main() { // set nAllocatedSize to be between CommitFloor and CommitCeiling size_t nAllocatedSize = 1024 * 1024 * 250; if(VirtualAlloc(NULL, nAllocatedSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE)) { printf(\"Committed 250 MB of memory\\n\"); while(1) { printf(\"Sleeping...\\n\"); Sleep(5000); } } } I executed the binary on 2 of my machines, and the results threw me off completely. On one of them, it was registered after a few minutes - but on the other one it wasn’t registered at all. They’re both running the same Windows 10 version, so what’s going on?\nReverse Engineering RdrpReadHeapLeakSettings To figure this out, I needed more information. Using Procmon, I was able to pinpoint the DLL which manages the DiagnosedApplications registry key:\nI figured I should start my analysis in the RdrpReadHeapLeakSettings function. I hoped it would help me understand the settings better. Take DetectionInterval, for example; it’s 0x1E, or 30 decimal - but 30 what? seconds? minutes? I had no idea.\nThis turned out to be a great idea, because the function transforms each value in a way that enabled me to understand what it means. For example, the DetectionInterval value is multiplied by 86400 after it is read from the registry. 86400 happens to be 60 * 60 * 24. This means DetectionInterval is stored days, and is converted to seconds:\nIn a similar fashion, I was able to conclude that TimerInterval is stored in minutes.\nDetectionInterval is stored in a global variable after it’s converted to seconds - to make it available for other functions to use. This is also the case for CommitThreshold, MaxReports and TimerInterval. However, both CommitFloor and CommitCeiling aren’t stored anywhere after they’re read. I doubt whether they’re actually used at all!\nThe next value I looked at is CommitThreshold, which seems to be 5 by default. After it is read from the registry, the function checks if it’s between 1 to 100:\nAfter that, there’s a call to NtQuerySystemInformation to get a SystemBasicInformation struct. Unfortunately, the structure of this struct is not documented on MSDN:\nNevertheless, I found documentation for it on some other, rather questionable website. Then, I was able to define it as a struct in IDA Pro. What I found then, was the explanation to the confusing results of my test:\nCommitThreshold is multiplied by (PageSize * NumberOfPhysicalPages) / 100. That lead me to conclude it’s the amount of memory an application has to commit in order to get diagnosed, as a percentage of the total amount of physical memory on the system.\nI was able to verify this theory through further testing. This artifact behaves differently depending on the amount of RAM installed in the machine.\nThe 250MBs my test application allocated are more than 5 percent out of the 4GBs of RAM installed in the first machine I tested on, but they’re less than 5 percent out of the 8GBs installed in my other machine.\nLooking at RdrpIdentifyTargetProcess What happens if the Memory Leak Diagnoser is triggered, and there are multiple processes with a high enough amount of committed memory to be diagnosed? Well, only one of them is chosen to be registered. I wanted to figure out how this choice is made, so the next function I looked at was RdrpIdentifyTargetProcess.\nFirst, it calls RdrpGetProcessInformation, which in turn uses the NtQuerySystemInformation API call; this time - to get an array of SYSTEM_PROCESS_INFORMATION structures, one for each running process:\nThese structures contain information about the resource usage of each process. Later, it seems like this array is sorted by the amount of committed memory in each process:\nAnswering my Research Questions At this point, I had a solid and complete theory, which I have tested and verified:\nThe Memory Leak Diagnoser is triggered every TimerInverval minutes. When triggered, it gets a list of all running processes, and sorts them by their amount of committed memory (in descending order). Then, it chooses the first process on the list which:\nHas committed at least CommitThreshold percent out of the total amount of physical memory installed. Wasn’t already chosen in the last DetectionInterval days. A sub-key beneath the DiagnosedApplications key is then created (if it doesn’t exist already) for the chosen process, and the LastDetectionTime is updated.\nEdit: some built-in executables are chosen to be diagnosed, but are not registered.\nWhy? Further research is needed.\nClosing Thoughts That’s all! I hope you found this short research interesting. This artifact is not all that powerful, because only the applications that commit a large amount of memory are registered. Nonetheless, it was quite fun to research. I’m not super experienced in using IDA and reverse engineering, but I think I did a decent job. Let me know what you think!\n",
  "wordCount" : "1070",
  "inLanguage": "en",
  "datePublished": "2022-07-20T00:00:00Z",
  "dateModified": "2022-07-20T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Harel Segev"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://harelsegev.github.io/posts/the-mystery-of-the-heapleakdetection-registry-key/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "RAT In Mi Kitchen",
    "logo": {
      "@type": "ImageObject",
      "url": "https://harelsegev.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://harelsegev.github.io/" accesskey="h" title="RAT In Mi Kitchen (Alt + H)">RAT In Mi Kitchen</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://harelsegev.github.io/posts/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://harelsegev.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://harelsegev.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://harelsegev.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://harelsegev.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://harelsegev.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://harelsegev.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      The Mystery of the HeapLeakDetection Registry Key
    </h1>
    <div class="post-meta"><span title='2022-07-20 00:00:00 +0000 UTC'>July 20, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;1070 words&nbsp;·&nbsp;Harel Segev

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#looking-at-the-settings">Looking at the Settings</a></li>
    <li><a href="#reverse-engineering-rdrpreadheapleaksettings">Reverse Engineering <em>RdrpReadHeapLeakSettings</em></a></li>
    <li><a href="#looking-at-rdrpidentifytargetprocess">Looking at <em>RdrpIdentifyTargetProcess</em></a></li>
    <li><a href="#answering-my-research-questions">Answering my Research Questions</a></li>
    <li><a href="#closing-thoughts">Closing Thoughts</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>I was working on a case the other day, when I first came across a rather interesting registry key, <code>HKLM\Software\Microsoft\RADAR\HeapLeakDetection\DiagnosedApplications</code>. It caught my eye, because it has sub-keys for (what appears to be) applications executed on the system. This is what it looks like on my own system:</p>
<p><img loading="lazy" src="images/regedit_key_hierarchy.png" alt=""  />
</p>
<p>It has quite a few sub-keys, and each one has a <em>LastDetectionTime</em> QWORD value, containing what appears to be a Windows FILETIME timestamp:</p>
<p><img loading="lazy" src="images/regedit_last_detection_time.png" alt=""  />
</p>
<p>This key is associated with the Memory Leak Diagnoser component of Windows Resource Exhaustion Detection and Resolution (RADAR). RADAR is a technology embedded in Windows to detect memory leaks in real-time, so that data can be collected and used to correct issues in applications.</p>
<p>RADAR is surprisingly old; it was introduced in Windows Vista. Nevertheless, I couldn&rsquo;t find any research into this registry key - so I had to conduct my own. With forensics in mind, I tried to answer these 2 questions:</p>
<ul>
<li>Under what conditions is a sub-key created beneath the <em>DiagnosedApplications</em> key?</li>
<li>Under what conditions is the <em>LastDetectionTime</em> value updated?</li>
</ul>
<p>My research was conducted on Windows 10 machines, and therefore may not apply to prior versions of Windows.</p>
<h2 id="looking-at-the-settings">Looking at the Settings<a hidden class="anchor" aria-hidden="true" href="#looking-at-the-settings">#</a></h2>
<p>Luckily, there&rsquo;s a <em>Settings</em> key beneath the <em>HeapLeakDetection</em> key:</p>
<p><img loading="lazy" src="images/regedit_settings.png" alt=""  />
</p>
<p>Settings are always helpful when you&rsquo;re trying to figure out how something works. Looking at these values, I already had some hypotheses. I figured whether an application is diagnosed has something to do with the amount of memory it allocated.</p>
<p>I had a guess that <em>CommitFloor</em> and <em>CommitCeiling</em> are actually in megabytes, and that the amount of committed memory has to lie between them for a process to be registered. That lead me to write a little C program, to test this theory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;Windows.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// set nAllocatedSize to be between CommitFloor and CommitCeiling
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    size_t nAllocatedSize <span style="color:#f92672">=</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">250</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(VirtualAlloc(NULL, nAllocatedSize, MEM_RESERVE <span style="color:#f92672">|</span> MEM_COMMIT, PAGE_READWRITE)) {
</span></span><span style="display:flex;"><span>        printf(<span style="color:#e6db74">&#34;Committed 250 MB of memory</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#e6db74">&#34;Sleeping...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>            Sleep(<span style="color:#ae81ff">5000</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>I executed the binary on 2 of my machines, and the results threw me off completely. On one of them, it was registered after a few minutes - but on the other one it wasn&rsquo;t registered at all. They&rsquo;re both running the same Windows 10 version, so what&rsquo;s going on?</p>
<h2 id="reverse-engineering-rdrpreadheapleaksettings">Reverse Engineering <em>RdrpReadHeapLeakSettings</em><a hidden class="anchor" aria-hidden="true" href="#reverse-engineering-rdrpreadheapleaksettings">#</a></h2>
<p>To figure this out, I needed more information. Using Procmon, I was able to pinpoint the DLL which manages the <em>DiagnosedApplications</em> registry key:</p>
<p><img loading="lazy" src="images/procmon.png" alt=""  />
</p>
<p>I figured I should start my analysis in the <em>RdrpReadHeapLeakSettings</em> function. I hoped it would help me understand the settings better. Take <em>DetectionInterval</em>, for example; it&rsquo;s 0x1E, or 30 decimal - but 30 what? seconds? minutes? I had no idea.</p>
<p><img loading="lazy" src="images/physics_meme.png" alt=""  />
</p>
<p>This turned out to be a great idea, because the function transforms each value in a way that enabled me to understand what it means. For example, the <em>DetectionInterval</em> value is multiplied by 86400 after it is read from the registry. 86400 happens to be 60 * 60 * 24. This means <em>DetectionInterval</em> is stored days, and is converted to seconds:</p>
<p><img loading="lazy" src="images/ida32_DetectionInterval.png" alt=""  />
</p>
<p>In a similar fashion, I was able to conclude that <em>TimerInterval</em> is stored in minutes.</p>
<p><em>DetectionInterval</em> is stored in a global variable after it&rsquo;s converted to seconds - to make it available for other functions to use. This is also the case for <em>CommitThreshold</em>, <em>MaxReports</em> and <em>TimerInterval</em>. However, both <em>CommitFloor</em> and <em>CommitCeiling</em> aren&rsquo;t stored anywhere after they&rsquo;re read. I doubt whether they&rsquo;re actually used at all!</p>
<p>The next value I looked at is <em>CommitThreshold</em>, which seems to be 5 by default. After it is read from the registry, the function checks if it&rsquo;s between 1 to 100:</p>
<p><img loading="lazy" src="images/ida64_CommitThreshold_01.png" alt=""  />
</p>
<p>After that, there&rsquo;s a call to <em>NtQuerySystemInformation</em> to get a <em>SystemBasicInformation</em> struct. Unfortunately, the structure of this struct is not documented on MSDN:</p>
<p><img loading="lazy" src="images/msdn_SystemBasicInformation.png" alt=""  />
</p>
<p>Nevertheless, I found documentation for it on some other, rather questionable website. Then, I was able to define it as a struct in IDA Pro. What I found then, was the explanation to the confusing results of my test:</p>
<p><img loading="lazy" src="images/ida64_CommitThreshold_02.png" alt=""  />
</p>
<p><em>CommitThreshold</em> is multiplied by <code>(PageSize * NumberOfPhysicalPages) / 100</code>. That lead me to conclude it&rsquo;s the amount of memory an application has to commit in order to get diagnosed, as a percentage of the total amount of physical memory on the system.</p>
<p>I was able to verify this theory through further testing. This artifact behaves differently depending on the amount of RAM installed in the machine.</p>
<p>The 250MBs my test application allocated are more than 5 percent out of the 4GBs of RAM installed in the first machine I tested on, but they&rsquo;re less than 5 percent out of the 8GBs installed in my other machine.</p>
<h2 id="looking-at-rdrpidentifytargetprocess">Looking at <em>RdrpIdentifyTargetProcess</em><a hidden class="anchor" aria-hidden="true" href="#looking-at-rdrpidentifytargetprocess">#</a></h2>
<p>What happens if the Memory Leak Diagnoser is triggered, and there are multiple processes with a high enough amount of committed memory to be diagnosed? Well, only one of them is chosen to be registered. I wanted to figure out how this choice is made, so the next function I looked at was <em>RdrpIdentifyTargetProcess</em>.</p>
<p>First, it calls <em>RdrpGetProcessInformation</em>, which in turn uses the <em>NtQuerySystemInformation</em> API call; this time - to get an array of <em>SYSTEM_PROCESS_INFORMATION</em> structures, one for each running process:</p>
<p><img loading="lazy" src="images/ida32_process_list.png" alt=""  />
</p>
<p>These structures contain information about the resource usage of each process. Later, it seems like this array is sorted by the amount of committed memory in each process:</p>
<p><img loading="lazy" src="images/ida32_qsort.png" alt=""  />
</p>
<h2 id="answering-my-research-questions">Answering my Research Questions<a hidden class="anchor" aria-hidden="true" href="#answering-my-research-questions">#</a></h2>
<p>At this point, I had a <del>solid and complete</del> theory, which I have tested and verified:</p>
<p>The Memory Leak Diagnoser is triggered every <em>TimerInverval</em> minutes. When triggered, it gets a list of all running processes, and sorts them by their amount of committed memory (in descending order). Then, it chooses the first process on the list which:</p>
<ul>
<li>Has committed at least <em>CommitThreshold</em> percent out of the total amount of physical memory installed.</li>
<li>Wasn&rsquo;t already chosen in the last <em>DetectionInterval</em> days.</li>
</ul>
<p>A sub-key beneath the <em>DiagnosedApplications</em> key is then created (if it doesn&rsquo;t exist already) for the chosen process, and the <em>LastDetectionTime</em> is updated.</p>
<p><strong>Edit:</strong> some built-in executables are chosen to be diagnosed, but are not registered.<br>
Why? Further research is needed.</p>
<h2 id="closing-thoughts">Closing Thoughts<a hidden class="anchor" aria-hidden="true" href="#closing-thoughts">#</a></h2>
<p>That&rsquo;s all! I hope you found this short research interesting. This artifact is not all that powerful, because only the applications that commit a large amount of memory are registered. Nonetheless, it was quite fun to research. I&rsquo;m not super experienced in using IDA and reverse engineering, but I think I did a decent job. Let me know what you think!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://harelsegev.github.io/tags/registry/">Registry</a></li>
      <li><a href="https://harelsegev.github.io/tags/heapleakdetection/">HeapLeakDetection</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://harelsegev.github.io/posts/the-forensic-value-of-the-other-wsh-registry-key/">
    <span class="title">« Prev</span>
    <br>
    <span>The Forensic Value of the (Other) WSH Registry Key</span>
  </a>
  <a class="next" href="https://harelsegev.github.io/posts/resolving-file-paths-using-the-mft/">
    <span class="title">Next »</span>
    <br>
    <span>Resolving File Paths Using the MFT</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share The Mystery of the HeapLeakDetection Registry Key on twitter"
        href="https://twitter.com/intent/tweet/?text=The%20Mystery%20of%20the%20HeapLeakDetection%20Registry%20Key&amp;url=https%3a%2f%2fharelsegev.github.io%2fposts%2fthe-mystery-of-the-heapleakdetection-registry-key%2f&amp;hashtags=Registry%2cHeapLeakDetection">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share The Mystery of the HeapLeakDetection Registry Key on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fharelsegev.github.io%2fposts%2fthe-mystery-of-the-heapleakdetection-registry-key%2f&amp;title=The%20Mystery%20of%20the%20HeapLeakDetection%20Registry%20Key&amp;summary=The%20Mystery%20of%20the%20HeapLeakDetection%20Registry%20Key&amp;source=https%3a%2f%2fharelsegev.github.io%2fposts%2fthe-mystery-of-the-heapleakdetection-registry-key%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share The Mystery of the HeapLeakDetection Registry Key on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fharelsegev.github.io%2fposts%2fthe-mystery-of-the-heapleakdetection-registry-key%2f&title=The%20Mystery%20of%20the%20HeapLeakDetection%20Registry%20Key">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share The Mystery of the HeapLeakDetection Registry Key on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fharelsegev.github.io%2fposts%2fthe-mystery-of-the-heapleakdetection-registry-key%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share The Mystery of the HeapLeakDetection Registry Key on whatsapp"
        href="https://api.whatsapp.com/send?text=The%20Mystery%20of%20the%20HeapLeakDetection%20Registry%20Key%20-%20https%3a%2f%2fharelsegev.github.io%2fposts%2fthe-mystery-of-the-heapleakdetection-registry-key%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share The Mystery of the HeapLeakDetection Registry Key on telegram"
        href="https://telegram.me/share/url?text=The%20Mystery%20of%20the%20HeapLeakDetection%20Registry%20Key&amp;url=https%3a%2f%2fharelsegev.github.io%2fposts%2fthe-mystery-of-the-heapleakdetection-registry-key%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer><script src="https://utteranc.es/client.js"
        repo="harelsegev/harelsegev.github.io"
        issue-term="pathname"
        label="blog comment"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://harelsegev.github.io/">RAT In Mi Kitchen</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
